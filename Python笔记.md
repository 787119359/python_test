# Python基础语法




## 一、第一个程序

`print(hello world!)`

输出一句话 print('内容')

---



## 二、注释

### 1. 概念

**1.1 对代码做一些描述, 提高代码的可读性**

1.2 **注释不会被显示出来**

### 2. 分类

#### 2.1 单行注释

* 在注释的最前面加 # 号
* 建议 # 与 注释内容之间 至少保留一个空格
* 适合: 简短的描述, 注释

#### 2.2 多行注释

* 一对 三引号 (单双引号均可)

* 适合: 较长的描述

```
'''
	这是注释第一行
	这是注释第二行
	这是注释第三行
'''
```

### 3. 友情提醒

* 注释 并非越多越好. 若一目了然, 则不需要注释

* 对于功能性的 多行代码, 则在功能的最前面写明注释

* 多行注释 不能嵌套使用

---



## 三、打印输出

1. **print(内容)**

2. **print(内容1,内容2,内容3, ...)**

3. **print(内容1,内容2, ...,end="值")**

4. **print(**  

​         内容1 \

​         内容2 \

​         内容3 \

​         ...  

​        **)**  

相对而言,第四种写法使用频率较低

---



## 四、Python 排版缩进

### 1. Python 对代码的书写要求非常严格

[Google 官方版](https://google.github.io/styleguide/pyguide.html)

[菜鸟中文版](http://www.runoob.com/w3cnote/google-python-styleguide.html)

### 2. 常规缩进

2.1 以 4个空格作为缩进. 默认要顶格

2.2 同级代码 需要保持缩进一致

### 3. 排版

> *  python中, 一行只有一条命令
>
> * 多条命令需要换行
>
> * 一条命令 最好不要超过 80个字符

### 4. 错误案例

`print('诸葛亮')    print('智商太低会传染')`

### 5. 正确案例

```
print('诸葛亮')  
print('智商太低会传染')
```

---



## 五、变量

### 1. 定义

> 用于存储数据. 类似于数学中的未知数
>
> 每定义一个变量, 都会分配一个内存

### 2. 格式

* 格式1:
变量名 = 值

* 格式2:
变量名1 = 变量名2 = 变量名3 = ... = 值

```
a = b = c = 100
print(a, b, c)
print( id(a) )
print( id(b) )
print( id(c) )
```
> 发现: 一次性给 多个不同的变量 赋予同一个值, 内存也是一样的

> 坑点:在定义是, 没有给变量赋值, 则会报错, 被认为是 未定义变量

### 3. 命名规范

3.1 由数字, 字母 和 下划线组成

3.2 不能以 数字开头

3.3 严格区分大小写

3.4 不能使用 关键字(保留字)

> 查看 Python 关键字
> `import keyword`
> `print( keyword.kwlist )`

3.5 支持中文变量名,但是不推荐使用

---

### 4.  变量操作

#### 4.1 修改变量

> 在已有的变量基础之上, 再次赋值, 就是修改

#### 4.2 删除变量

>通过 关键字 del来删除变量
>
>> del 变量名
>>
>> del 变量名1, 变量名2, ...

---



## 六、数据类型

### 1. 定义

变量的值能写成的样子

数据 一共有6种 标准类型

如果变量值 超出这6种以外, 都是不符合规范的

### 2. 数据类型

* Number --- 数字

* String --- 字符串

* List   --- 列表

* Tuple  --- 元组

* Set    --- 集合

* Dict   --- 字典

> 简单理解:
> 所有与数字相关的 都可以用 Number 类型
> 所有与字母, 数字, 标点, 文字等相关的都可以使用 String 类型
> 列表, 元组, 集合, 字典都是 复合类型, 可以容纳多个数据类型, 多个值, 该类型属于高级类型

### 3. 归类

* 可变类型: 定义后, 再次修改时, 是不会重新分配内存, 会在原来的基础上直接改

> ist, Set, Dict 属于可变类型

* 不可变类型: 定义后, 该内存中的值就不能被修改.
如果强制修改的话, 那么会重新分配一个内存

> Number, String, Tuple 属于不可变类型

---

练习

```
a = 10
b = a
b = 20

请问: 最后 a 和 b 的值分别是多少?
      最后 a 和 b 的内存一样吗???
```
---



## 七、Number-整型 int

### 1. 值

**值:正负整数**

* 注意:
	* 理论上 无限制
	* 实际上 受限于内存


### 2. 类型检测

**函数函数: `type( 变量 )`**

**返回值: 变量的数据类型**

```
a = 10
print( type(a) )

a = 1.5
print( type(a) )
```
输出结果:
> => <class 'int'>
> => <class 'float'>

### 3. 进制

|       | 前缀 |基数范围|
|---    |---   |---    |
|二进制  | 0b  | 0-1    |
|八进制  | 0o  |	0-7    |
|十进制  | 无  |	0-9    |
|十六进制|  0x |	0-9	a-f|

**任意进制 -> 十进制**

> 公式:  基数 * 进制^次方

* 说明: 次方是从 个位开始以 0次方出现
	 ​				十位 	... 	   1次方
	 				百位 	... 	   2次方
	​				...

```
1*2^3 + 1*2^2 + 1*2^1 + 0*2^0 = 
a = 10 			#十进制
a = 0b1110		#二进制
print(a)
```

```
1*8^1 + 2*8^0 = 10
a = 0o12 		#八进制
print(a)
```

```
10*16^2 + 11*16^1 + 5*16^0
a = 0xab5 		#十六进制
print(a)
```

> 十进制 -> 任意进制
> 十进制 除以 进制数, 结果倒取余


### 4. int 转换

**将其他类型 转为 int类型  int()**

```
a = 2.5
print( type(a) )
result = int( a ) 	# 将a 送进int(), 转为int, 结果送给result
print( result, type(result))
print( a, type(a))
```
输出结果:
> => <class 'float'>
> => 2 <class 'int'>
> => 2.5 <class 'float'>

------------------------------------



## 八、Number-浮点 float

### 1. 值

#### 1) 整数 + 小数	
#### 2) 科学计数法

```
a = 2.5
print(a, type(a))
a = 2e5 	# 2 * 10的5次方
print(a, type(a))
```
输出结果:

> => 2.5 <class 'float'>
> => 200000.0 <class 'float'>

### 2. 精度

#### 1) 有效位数
* 从前向后, 第一个非0数字开头, 向后保留17位

```
a = 1.1234567890123456789
print(a)
a = 0.001234567890123456789
print(a)
```

输出结果:
> => 1.1234567890123457
> => 0.0012345678901234567

#### 2) 控制小数位

```
a = 1.234567
a = round(a, 3)
print(a)
```

输出结果:
> => 1.235

#### 注意:
 	* python2中, 存在单精度和双精度
 	* python3中, 没有单精度, 只有双精度

### 3. float 转换

```
a = 2
print(a, type(a))
a = float(a)
print(a, type(a))
```

输出结果:
> => 2 <class 'int'>
> => 2.0 <class 'float'>

--------------------------------------



## 九、Number-复数 complex

### 1. 值

格式:  实数 + 虚数 j

```
a = 2 + 5j 	# 2是实数,  5是虚数
print(a, type(a))
```

输出结果:
> => (2+5j) <class 'complex'>

### 2. 获取实数/虚数

* 实数: real
* 虚数: imag

```
a = 2 + 5j
print(a.real, type(a.real))
print(a.imag, type(a.imag))
```

输出结果:
> => 2.0 <class 'float'>
> => 5.0 <class 'float'>

### 3. 作用
* _数在实际生活中, 看不出有什么应用, 就像 圆周率, sin, cos_
* _但是后期的 数据分析, 平面几何非常有用_

### 4. complex转换

**格式**: complex(实数, 虚数)		#虚数默认为0

```
a = 5.3
a = complex(a)
print(a, type(a))
```

输出结果:
> => (5.3+0j) <class 'complex'>   #虚数默认为0

```
a = 5
b = 2
result = complex(a, b)
print(result)
```

输出结果:
> => (5+2j)



--------------------------------------



## 十、Number-布尔

### 1. 值

**值: True 和 False**

> 注意: 首字母必须大写

```
a = True
print(a, type(a))
a = False
print(a, type(a))
```

输出结果:
> => True <class 'bool'>
> => False <class 'bool'>

### 2. 作用

* **bool值代表两种 极端状态, 常用于比较, 判断等**
	* True:  1, 真, 对, 开, 是, 存在, 可以
	* Flase: 0, 假, 错, 关, 否, 不存在, 不可以

`print( 1 > 2 )`
> 结果:
> => False

### 3. bool 转换
```
print( bool(10) )
print( bool(0) )
print( bool(0.0) )
print( bool(0+0j) )
print( bool(-5) )
```
输出结果:
> => True
> => False
> => False
> => False
> => True

-------------------------------



## 十一、String 字符型

### 1. 定义

 * **可用于表达 数字, 字母, 标点, 汉字 等等内容**

### 2. 格式

* 2.1 单引号

* 2.2 双引号

* 2.3 三引号

```
a1 = '小时候, 喜欢爬树么?'
a2 = "小时候, 进入女澡堂 洗澡么?"
a3 = '''小时候, 经常把小弟弟往插座里面插'''
a4 = """小时候, 想过你会坐着这里学Python"""
a5 = "I give you face, you don't have face"

print(a1, type(a1))
print(a2, type(a2))
print(a3, type(a3))
print(a4, type(a4))
print(a5, type(a5))
```
输出结果:
> => 小时候, 喜欢爬树么? <class 'str'>
> => 小时候, 进入女澡堂 洗澡么? <class 'str'>
> => 小时候, 经常把小弟弟往插座里面插 <class 'str'>
> => 小时候, 想过你会坐着这里学Python <class 'str'>

> 三引号被变量引用时, 就是 字符串
> 三引号若没有被引用时, 就是 注释
> 单引号中 不要嵌套单引号
> 双引号中 不要嵌套双引号
> 三引号中 不要嵌套三引号
>
> > 小结: 引号支持互插, 不支持自插

### 3. 转义字符


**转义符:**\ 
通过转义符能将普通字符转为特殊字符
​			     将特殊字符转为普通字符


```
普通字符 -> 特殊字符
\n 			换行
\t  		制表符 	tab
\r 			回车
```

```
特殊字符 -> 普通字符
\'
\"
\\
...
```

```
a5 = 'I give you face, you don\'t have face'
print(a5)
```

输出结果:
> => I give you face, you don't have face


### 4. 原始字符串

**r'字符串内容'**
**R'字符串内容'**
> 会将字符串内容原样输出

```
a = '上面的人喜欢做着\n下面的人喜欢躺着'
print(a)
a = r'上面的人喜欢做着\n下面的人喜欢躺着'
print(a)
a = R'上面的人喜欢做着\n下面的人喜欢躺着'
print(a)
```
输出结果:
> => 上面的人喜欢做着
> => 下面的人喜欢躺着
> => 上面的人喜欢做着\n下面的人喜欢躺着
> => 上面的人喜欢做着\n下面的人喜欢躺着

### 5. 格式化字符串

```
%s 	字符串
%d  整数 (十进制)
%f  小数
%e 	科学计数法
%E 	科学计数法	
%o 	八进制
%x  十六进制
%X  十六进制
```

* 格式化写法
	1. '字符串内容' % 变量名
	2. '字符串内容' % (变量名1, 变量名2, ...)
```
name = '小明'
age = 18
print( '我们的大帅哥%s, 今年 %d 岁' % (name, age) )
```
* 非格式化写法
```
name = '小明'
age = 18
print( '我们的大帅哥',name,今年,age,岁' )
```

-------------------------------

### 6. 字符串操作

#### 6.1 拼接 +

```
a = '金庸小说: '
b = '飞雪连天射白鹿, 笑书神侠倚碧鸳'
c = a + b
print(c)
```
> => 金庸小说: 飞雪连天射白鹿, 笑书神侠倚碧鸳

#### 6.2 复制 *

```
a = '母鸡'
b = a * 3
print(b)
```
> => 母鸡母鸡母鸡


#### 6.3 索引 []

```
#    0 1 23 4 5 67 8 90 12 3 4 5
a = '营长说:敌人逼上来了,我们出击吧'

print( a[0] )
print( a[1] )
print( a[2] )
print( a[-1] )
print( a[-2] )
print( a[-3] )
```
> => 营
> => 长
> => 说
> => 吧
> => 击
> => 出

#### 6.4 取片 [::]

```
#    0 1 23 4 5 67 8 90 12 3 4 5
a = '营长说:敌人逼上来了,我们出击吧'
print( a[:]) 		# 开头 ~ 末尾
print( a[::]) 		# 开头 ~ 末尾
print( a[0:7])		# 索引0 ~ 索引7 (不包含索引7)
print( a[2:7]) 		# 索引2 ~ 索引7 (不包含索引7)
print( a[2:])  		# 索引2 ~ 末尾
print( a[:2]) 		# 开头 ~ 索引2 (不包含索引2)
print( a[2:13:3]) 	# 索引2 ~ 索引13, 步长3 (不包含索引13)
print( a[2:13:4]) 	# 索引2 ~ 索引13, 步长4 (不包含索引13)
```
> => 营长说: 敌人逼上来了, 我们出击吧
> => 营长说: 敌人逼上来了, 我们出击吧
> => 营长说: 敌人
> => 说: 敌人
> => 说: 敌人逼上来了, 我们出击吧
> => 营长
> => 说敌上,
> => 说人了

### 7. String 转换

```
a = 100
a = str(a)
print(a, type(a))

a = True
a = str(a)
print(a, type(a)) 
```
> => 100 <class 'str'>
> => True <class 'str'>



## 十二、List 列表

### 1. 定义

> **由一堆数据组成的有序序列**

### 2. 格式
> **列表名 = [值1, 值2, 值3, ...]**

```
a = [] 	# 空列表
print(a, type(a))

a = ['黄焖鸡', '兰州拉面', '沙县小吃', 10, 10.5, 1+2j, True]
print(a, type(a))
```
> => [] <class 'list'>
> => ['黄焖鸡', '兰州拉面', '沙县小吃', 10, 10.5, (1+2j), True] <class 'list'>


### 3. 列表操作

#### 3.1 访问

```
#     0 		1 			2
a = ['黄焖鸡', '兰州拉面', '沙县小吃']
#  	  -3 		-2 		 	-1
print( a[0] )
print( a[-1] )
# print( a[99] ) 	# 访问一个不存在的索引, 则会报错
```
> => 黄焖鸡
> => 沙县小吃

#### 3.2 插入
* 1) 列表名.append(值) 		在最后追加一个数据

```
a = ['黄焖鸡', '兰州拉面', '沙县小吃']
a.append('麻辣烫')
print(a)
```
> => ['黄焖鸡', '麻辣香锅', '兰州拉面', '沙县小吃', '麻辣烫']

* 2) 列表名.insert(索引, 值)  在指定索引插入值, 原有索引会依次向后推1步

```
a = ['黄焖鸡', '兰州拉面', '沙县小吃']
a.insert(1, '麻辣香锅')
print(a)
print(a[1])
print(a[2])
a.insert(99, '重庆鸡公煲') 	# 插入的索引与原有索引的最大值 差距超过1, 则认为原有最大索引+1
print(a)
print(a[4])
print(a[99])
```
> => ['黄焖鸡', '麻辣香锅', '兰州拉面', '沙县小吃']
> => 麻辣香锅
> => 兰州拉面
> => ['黄焖鸡', '麻辣香锅', '兰州拉面', '沙县小吃',  '重庆鸡公煲']
> => 重庆鸡公煲
> => 报错


#### 3.3 修改

**通过已有的索引 来重新赋值**

```
a = ['黄焖鸡', '麻辣香锅', '兰州拉面', '沙县小吃', '麻辣烫', '重庆鸡公煲']
a[1] = '鸭血粉丝汤'
print(a)
```
> => ['黄焖鸡', '鸭血粉丝汤', '兰州拉面', '沙县小吃', '麻辣烫', '重庆鸡公煲']


#### 3.4 删除

 * del 列表名[索引] 	删除已有的索引值, 后面的索引依次向前推1步
* del 列表名 		删除整个列表

```
a = ['黄焖鸡', '麻辣香锅', '兰州拉面', '沙县小吃', '麻辣烫', '重庆鸡公煲']
del a[1]
print(a)
print(a[1])

del a
# print(a)
```
> => ['黄焖鸡', '兰州拉面', '沙县小吃', '麻辣烫', '重庆鸡公煲']
> => 兰州拉面


#### 3.5 合并

```
a = ['黄焖鸡', '兰州拉面']
b = ['沙县小吃', '麻辣烫']
print(a+b)
```

> => ['黄焖鸡', '兰州拉面', '沙县小吃', '麻辣烫']

#### 3.6 复制

```
a = ['黄焖鸡', '兰州拉面']
print( a*2 )
```
> => ['黄焖鸡', '兰州拉面', '黄焖鸡', '兰州拉面']


#### 3.7 取片, 分片

```
# 	   0	   1	  2		  3		  4		 5		 6
a = ['刘备', '关羽', '张飞', '赵云', '马超', '黄忠', '诸葛亮']
print(a[0:5]) 		# 索引0 ~ 索引5 (不包含索引5)
print(a[2:5]) 		# 索引2 ~ 索引5 (不包含索引5)
print(a[2: ]) 		# 索引2 ~ 末尾
print(a[ :2]) 		# 开头 ~ 索引2 (不包含索引2)
print(a[ : ]) 		# 开头 ~ 末尾 
print(a[ : : ]) 	# 开头 ~ 末尾 
print(a[0:5:2]) 	# 开头 ~ 末尾 
```
> => ['刘备', '关羽', '张飞', '赵云', '马超']
> => ['张飞', '赵云', '马超']
> => ['张飞', '赵云', '马超', '黄忠', '诸葛亮']
> => ['刘备', '关羽']
> => ['刘备', '关羽', '张飞', '赵云', '马超', '黄忠', '诸葛亮']
> => ['刘备', '关羽', '张飞', '赵云', '马超', '黄忠', '诸葛亮']
> => ['刘备', '张飞', '马超']

---------------------------------------



## 十三、Tuple 元组

### 1. 定义

> 由一堆数据组成的有序序列.
但不能修改数据, 是不可变类型之一

### 2. 格式

**元组名 = (值1, 值2, 值3, ...)**

```
a = () 	# 空元组
a = ('男', '女')
print(a, type(a))
```
> => ('男', '女') <class 'tuple'>

* 注意
若()中只有一个值时, 会将() 理解成一个整体的意思
所以, 需要在值的后面, 补一个逗号

```
a = (10)
print(a, type(a))
a = (10, )
print(a, type(a))
```
> => 10 <class 'int'>
> => (10,) <class 'tuple'>

### 3. 元组操作

#### 3.1 访问

* 通过 已有的索引 来访问元组

```
#  	  0       1      2         3
a = ('天蓬', '卷帘', '弼马温', '金蝉子')
print( a[0] )
print( a[-1] )
```
> => 天蓬
> => 金蝉子

#### 3.2 修改, 插入, 删除

* 由于元组 属于不可变类型之一, 所以无法通过索引来修改, 插入, 删除

#### 3.3 合并 +

```
a = ('天蓬',)
b = ('卷帘',)
print(a+b)
```
> => ('天蓬', '卷帘')

#### 3.4 重复 *

```
a = ('天蓬',)
print( a*3 )
```
> => ('天蓬', '天蓬', '天蓬')

#### 3.5 分片, 取片[::]

```
#  	  0       1      2         3
a = ('天蓬', '卷帘', '弼马温', '金蝉子')
print( a[::] )
print( a[1:3:1] )
```
> => ('天蓬', '卷帘', '弼马温', '金蝉子')
> => ('卷帘', '弼马温')

------------------------------------



## 十四、Dict 字典

### 1. 定义

* **由一堆 键值对 组成的有序序列
键: 与索引类似, 支持数字, 字母等类型
索引都是数字, 且不可设置**

* **键必须手动设置, 且唯一 (若发生等价键, 后面会覆盖前面的值)**

* **键必须是不可变类型**

* **值: 任意类型**
> 可变类型: list  set  dict
不可变: number  string  tuple

### 2. 格式

* **字典名 = { 键:值, 键:值, ...}**

```
a = {} 		# 空字典
print(a, type(a))
a = {'name':'关羽', 'nickname':'武圣', 1:'关公', False:'温酒斩华雄'}
print(a, type(a))
```
> => {} <class 'dict'>
> => {'name': '关羽', 'nickname': '武圣', 1: '关公', False: '温酒斩华雄'} <class 'dict'>

```
a = { 1: [1,2,3] }
a = { 1: {1:2, 3:4} }
print(a)
print(a[1])
print(a[1][3])
```
> => {1: {1: 2, 3: 4}}
> => {1: 2, 3: 4}
> => 4

### 3. 字典操作

#### 3.1 访问
* **通过键来访问值**

```
a = {'name':'关羽', 'nickname':'武圣', 1:'关公', False:'温酒斩华雄'}

print( a['name'] )
print( a['nickname'] )
print( a[1] )
print( a[False] )
# print( a['xxx'] ) 	# 访问不存在的 键, 则会报错
```
> => 关羽
> => 武圣
> => 关公
> => 温酒斩华雄


#### 3.2 修改

* **通过已存在的键来修改值**

```
a = {'name':'关羽', 'nickname':'武圣', 1:'关公', False:'温酒斩华雄'}
a['name'] = '小明'
print(a)
```
> => {'name': '小明', 'nickname': '武圣', 1: '关公', False: '温酒斩华雄'}

#### 3.3 插入
* **通过不存在的键来插入值**

```
a = {'name':'关羽', 'nickname':'武圣', 1:'关公', False:'温酒斩华雄'}
a['age'] = 18
print(a)
```
> => {'name': '小明', 'nickname': '武圣', 1: '关公', False: '温酒斩华雄', 'age': 18}

#### 3.4 删除

* **通过 del 字典名[键]来删除值**

```
a = {'name':'关羽', 'nickname':'武圣', 1:'关公'}
del a[1]
print(a)
```

> => {'name': '关羽', 'nickname': '武圣'}

---



## 十五、集合 Set

### 1. 定义

> 由一堆 不会重复的数据 组成的无序序列
其实, 就是没有键的字典

* **值:**
无序
    具有唯一性
    不可变类型

* **作用:** 
    去重
    关系测试

### 2. 格式

集合名 = {值1, 值2, 值3, ... }

```
a = {}      # 空字典, 而非空集合
print(a, type(a))

a = set()   # 空集合
print(a, type(a))

a = {'杜子腾', '毕云涛', '史珍香'}
print(a)
```

> => {} <class 'dict'>
> => set() <class 'set'>
> => {'史珍香', '毕云涛', '杜子腾'}

### 3. 去重

```
a = {10, 20, 30, 40, 20, 50, 20, 60}
print(a)

a = [10, 20, 30, 40, 20, 50, 20, 60]
a = set(a)
a = list(a)
print(a)
```
> => {40, 10, 50, 20, 60, 30}
> => [40, 10, 50, 20, 60, 30]

### 4.关系测试

```
a = {'1','2','3','4','5'}
b = {'4','5','6','7'}
```
* **交集 &**
`print( a & b )`

> => {'5', '4'}

* **并集 |**
`print( a | b )`

> => {'6', '1', '7', '5', '2', '4', '3'}

* **差集 -**
```
print( a - b )  # a 相对于 b的差集
print( b - a ) # b 相对于 a的差集
```
> => {'1', '2', '3'}
> => {'7', '6'}

* **对称差集 ^**

`print( a ^ b ) `

> => {'6', '7', '1', '2', '3'}

### 5. 集合操作

#### 5.1 添加

* 集合名.add(值)

```
a = {'杜子腾', '毕云涛', '史珍香'}
a.add('郝爽')
print( a )
```

> => {'史珍香', '毕云涛', '郝爽', '杜子腾'}

* 集合名.update(值)

```
a = {'杜子腾', '毕云涛', '史珍香'}
a.update( ('卜耀', '项耀') )
print(a)
```

> => {'史珍香', '毕云涛', '卜耀', '杜子腾', '项耀', '郝爽'}

* 利用 函数特性来实现的相关效果

```
a = set()
a.update('123456789')
print(a)
a = set('abcdefg')
print(a)

```
> => {'4', '3', '5', '6', '7', '2', '8', '9', '1'}
> => {'a', 'c', 'd', 'e', 'b', 'g', 'f'}

#### 5.2 删除

* 集合名.remove(值)       值不存在则会报错
* 集合名.discard(值)      值不存在不会报错

```
a = {'杜子腾', '毕云涛', '史珍香'}
a.remove('史珍香')
print(a)

a.discard('杜子腾')
print(a)
```
> => {'杜子腾', '毕云涛'}
> => {'毕云涛'}


#### 5.3 访问,修改

* 没有索引,没有键, 无法单独获取集合值, 删除一个值

---



## 十六、类型转换

### 1. 基本类型
* Int, Float, Complex, Bool
* 分别是: int(),  float(),  complex(),  bool()

### 2. 注意
* 1) Int()  支持float, bool, 纯数字字符串 (不能含有任意字母)

* 2) Float() 支持float, int, bool, 数字字符串 (包含字母e, 小数点)

* 3) Complex() 支持int, float, bool, 数字字符串 (包含字母e, 小数点)

* 4) Bool() 以下值 都可以转为false,其余都是true 

> 整数0
小数0
复数0
空字符串
空容器
false 本身

### 3. str() 

* 任何类型 都可以转换为string

### 4. List(), Tuple(), Set()

* 支持string, list, tuple, set, dict 转换

### 5. Dict()
* 只有 二维容器 才能转为 字典

    * 一维列表
    ```
    a = ['a',1, 'b',2, 'c',3]
    ```

    * 二维列表
    ```
    a = {
            ('a',1),
            ('b',2),
            ('c',3),
        }
    ```

> 二维容器: 容器中 嵌套别的容器

---



## 十七、内存管理

> 任何程序 或 软件在运行时, 都是临时存放在内存中的

### 1. 引用

python内部使用引用计数, 来保持内存中对象的追踪

```
a = 10
# 分析:
#   10 是对象
#   a 是引用
#   
#   a引用了 对象10,  对象10 的引用计数为 1

b = 10
    b引用了 对象10, 对象10 的引用计数为 2  (有a, 还有b)
```

### 2. 垃圾回收机制

* 每定义一个变量, 都会在内存划分空间, 在内存里面的值都统称为对象

* 那么内存由于有上限, 那么python 在使用完变量, 就会查看 引用计数

* 如果 引用计数 = 0, python 会立马释放内存 ( 垃圾回收 )

```
# 小结:
#   对象在以下情况引用计数 + 1
#   1) 对象被创建:  a = 10
#   2) 对象被其他对象赋值: b = a
#   3) 被作为参数传递给函数: 函数名( a )
#   4) 作为容器对象的一个元素: x = [ 10, a, 03, ...]
#   
#   
#   对象在以下情况引用计数 - 1
#   1) 对象被销毁时: del a
#   2) 对象引用别的对象: a = 20
#   3) 引用离开了它的作用域时:  例如: 函数名(a)  在使用函数时, 计数+1, 一旦函数结束时, 计数-1
#   
# 强调: 变量并不是直接存储, 而是引用了一个内存地址
# 强调: 变量并不是直接存储, 而是引用了一个内存地址
# 强调: 变量并不是直接存储, 而是引用了一个内存地址
```


### 3. 循环垃圾回收

 * 当出现两个变量 互相引用, 但两个变量又没有别的引用, 也会被当做垃圾回收掉

 ```
# x = y
# y = x 
 ```


### 4. 内存池

* 在python运行期间, 会大量执行 内存malloc(分配)  和  free(释放), 导致python运行效率降低

* 为了能加速高频率数字, 引用内存池机制, 用于管理 小块内存的分配和释放只有在超过 小块内存, 才会去 malloc

> 小块内存:
> 整数范围: -5 ~ 256     
>
> > 只要在 范围之内, 都是事先分配好的内存, 不会变. 只有超过这个范围, 才会去找python重新分配内存.
---


## 十八、运算符

### 一. 算术运算符

#### 1. 基本运算
* \+ 加
* \- 减
* \* 乘
* / 除

#### 2. 取模

* 通俗说法:求余数
* 运算符号:%

**2.1 取模结果的正负**

​	取模结果取决于第二位数的正负

**2.2 取模结果的范围**

公式:  %(y-x+1) + x

#### 3. 指数

```
print( 2 ** 3 )     # 2的3次方
```
> => 8

#### 4. 整除

* 只留下整数, 去除小数

```
print( 10 // 4 )
```
> => 2

---

### 二. 赋值运算符

#### 1. 等于号

##### 1.1 单一赋值

`a = 10`

##### 1.2 连续赋值

`a = b = c = 20`

##### 1.3 多段赋值

`a,b,c = 1,2,3`

```
a,b = 5,10
a,b = b, a+b  # a,b = 10, 15
            # 先算 = 右边的, 再算 = 左边的
print(a, b)
```
> => 10 15

* 技巧: 交换变量

```
a = 5
b = 10
a,b = b,a
# 省略的临时内存
```


##### 1.4 剩余赋值

```
a,b,*c = 1,2,3,4,5,6,67,7
print( a, b )
print( c ,type(c))    # *c 将剩下来的没人要的数据 全部接收, 以 list 形式接收  
```
> => 1 2
> => [3, 4, 5, 6, 67, 7] <class 'list'>    


#### 2. 运算赋值

* +=

```
a += b    # a = a + b
```

* -=  

```
a -= b    # a = a - b
```
* *=
```
a *= b    # a = a * b
```
* /= 
```
a /= b    # a = a / b
```
* %= 
```
a %= b    # a = a % b
```
* //= 
```
a //= b    # a = a // b
```
* **=
```
a **= b    # a = a 的 b次幂
```

###  三. 比较运算符

> 所有的比较结果为 bool

* \> 和 >=
* \< 和 <=
* ==
判断两边的值是否相等
* !=
判断两边的值是否不等


### 四. 逻辑运算符

#### 1. 逻辑与

* 格式: x and y
* 规则: 
若x 为真, 那么结果就是y
若x 为假, 那么结果就是x

#### 2. 逻辑或

* 格式: x or y
* 规则:
若x 为真, 那么结果就是x
若x 为假, 那么结果就是y 

#### 3. 逻辑非

* 格式: not x
* 规则:
若x 为真, 那么结果就是 False
若x 为假, 那么结果就是 True

### 五. 身份运算符

#### 1. is

* 格式: X is Y
* 规则:
判断 x 和 y 是否来自同一个内存

#### 2. is not

* 格式: X is not Y

* 规则:
判断 x 和 y 是否来自不同的内存

### 六. 成员运算符

> 成员管理 支持string, list, tuple, set, dict

#### 1. in

#### 2. not in

```
a = ['古力娜扎', '迪丽热巴', '萨瓦迪卡', '马尔扎哈', '真皮沙发']

print( '马尔扎哈' in a )
print( '马尔扎哈' not in a )
```

> => True

> => False

---
### 七. 位运算符

> 位运算, 需要先转为二进制, 再运算.

#### 1. 按位与

* 格式: x & y
* 规则: 两者为1即为1,否则为0

```
a = 5 	# 0101
b = 12 	# 1100
print( a & b )
=> 4
```
> & 1 结果为1, 则为奇数
> & 1 结果为0, 则为偶数

#### 2. 按位或

* 格式: x | y
* 规则: 一个为1即为1,否则为0

```
a = 10 	# 1010
b = 5 	# 0101
print( a | b )
=> 15
```
> 奇数 | 1 为本身
> 偶数 | 1 则加1

#### 3. 按位异或

* 格式 : x ^ y
* 规则 : 相异为1,相同为0

```
a = 10 	# 1010
b = 8 	# 1000
print( a ^ b )
=> 2
```
> 奇数 ^ 1, 结果-1
> 偶数 ^ 1, 结果+1

#### 4. 按位取反

* 格式 : ~ x
* 规则 :` ~x  ===>  -x-1 `

#### 5. 左移

* 格式: x << num位
* 规则:二进制依次向左移动num位, 低位补0

>  `x << n  ==>  x*2的n次方`

#### 6. 右移

* 格式: x >> num位
* 规则: 二进制依次向右移动 num位, 高位补0, 低位丢弃

> `x >> n    ==> x // 2的n次方`

### 八. 运算符优先级

|运算符     |描述|
|----------|---------------------|
|**        |指数 (最高优先级)     |
|~ + -     |按位翻转, 一元加号和减号(最后两个的方法名为 +@ 和 -@)|
|* / % //  |乘，除，取模和取整除   |
|+ -	   |加法减法              |
|>> <<	   |右移，左移运算符       |
|&amp; 	   |位 'AND'             |
|^ \|      |位运算符              |
|<= < > >= |比较运算符            |
|<> == !=  |等于运算符            |
|= %= /= //= -= += *= **=|赋值运算符|
|is is not |身份运算符            |
|in not in |成员运算符            |
|and or not|逻辑运算符            |

---



## 十九、流程控制

* 定义
计算机中在执行程序是, 是按照指定的顺序从上往下依次执行, 有时也会跳过部分代码, 有时不断重复某段代码

* 流程控制主要分为3种:
    * 顺序结构
        从上往下依次执行, 即为顺序结构. 大多数程序默认就是该结构
    * 分支结构
        当代码执行到 分叉口时, 要进行选择向左向右, 一旦其中一个方向, 那么另一个方向将不会执行
    * 循环结构
        当遇见 某一段功能代码需要重复运行, 才能完成时, 则需要循环结构
        循环一般情况下, 总会停止循环, 或者突发情况停止循环, 需要借助 流程控制符

### 1. 分支结构 if

#### 1.1 短向分支

* 格式:
	```
	if 条件: true环境
	```

#### 1.2 单向分支

* 格式:
  ```
  if 条件:
  	true环境 (代码块)
  ```

#### 1.3 双向分支

* 格式:
	```
	if 条件:
   	 true环境 (代码块)
	else:
    	false环境 (代码块)
	```

#### 1.4 多向分支

* 格式:
	```
  if 条件1:
  	true环境1 (代码块)
  elif 条件2:
  	true环境2 (代码块)    
  elif 条件3:
  	true环境3 (代码块)
  ...
	```

#### 1.5 巣状分支

* 格式:
	```
  if 条件1:
  	if 条件2:
   		true环境2
  	else:
  		false环境2
  else:
  	if 条件3:
  		true环境3
  	else:
  		false环境3
	```



### 2. 循环结构之while

* 作用: 将某一部分的代码功能, 重复的执行, 直到不满足条件时, 就会结束循环

* 组成: 初始值,循环条件,循环增量

#### 2.1 循环1

* 格式: 

  ```
  while  条件:
  	true环境 (代码块)
  循环外的代码
  ```

#### 2.2 循环2

* 格式:

  ```
  while 条件: true环境
  ```

#### 2.3 循环3

* 格式:
	```
    while 条件:
        true环境 (代码块)
    else:
        false环境 (代码块)
	```

#### 2.4 无限循环
> 只要条件永远成立, 就能成为无限循环, 又称死循环



### 3.循环结构之for

#### 3.1 区间循环

* 格式:

    ```
    for 变量 in 区间:
        循环体 (代码块)
    ```

* 说明:
区间: range(start, stop, step)
	* start: 从start开始, 默认值为0
	* stop: 到stop结束, 不包含stop
	* step: 步长, 默认值为1

#### 3.2 else用法

* 格式:

    ```
    for 变量 in 区间:
    	循环体
    else:
    	进阶体
    ```

* 说明:
  这里的else是指, 当循环做完了就会进入 进阶体 (只进入一次)



### 4. 异常

* 定义:

​	异常也是流程控制之一, 叫做异常结构

​	在程序执行过程中, 如果 py解释器遇到错误, 则会立马停止程序执行, 并在控制台输出错误. 此为"异常"

​	在输出错误时, 该行为"抛出异常"	

* 常见报错:

  | 错误                  | 说明                                                         |
  | --------------------- | ------------------------------------------------------------ |
  | AssertError           | 断言语句（assert）失败                                       |
  | AttributeError        | 尝试访问未知的对象属性                                       |
  | EOFError              | 用户输入文件末尾标志EOF（Ctrl+d）                            |
  | FloatingPointError    | 浮点计算错误                                                 |
  | GeneratorExit         | generator.close()方法被调用的时候                            |
  | ImportError           | 导入模块失败的时候                                           |
  | IndexError            | 索引超出序列的范围                                           |
  | KeyError              | 字典中查找一个不存在的关键字                                 |
  | KeyboardInterrupt     | 用户输入中断键（Ctrl+c）                                     |
  | MemoryError           | 内存溢出（可通过删除对象释放内存）                           |
  | NameError             | 尝试访问一个不存在的变量                                     |
  | NotImplementedError   | 尚未实现的方法                                               |
  | OSError               | 操作系统产生的异常（例如打开一个不存在的文件）               |
  | OverflowError         | 数值运算超出最大限制                                         |
  | ReferenceError        | 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象 |
  | RecursionError        | 超出最大递归深度                                             |
  | RuntimeError          | 一般的运行时错误                                             |
  | StopIteration         | 迭代器没有更多的值                                           |
  | SyntaxError           | Python的语法错误                                             |
  | IndentationError      | 缩进错误                                                     |
  | TabError              | Tab和空格混合使用                                            |
  | SystemError           | Python编译器系统错误                                         |
  | SystemExit            | Python编译器进程被关闭                                       |
  | TypeError             | 不同类型间的无效操作                                         |
  | UnboundLocalError     | 访问一个未初始化的本地变量（NameError的子类）                |
  | UnicodeError          | Unicode相关的错误（ValueError的子类）                        |
  | UnicodeEncodeError    | Unicode编码时的错误（UnicodeError的子类）                    |
  | UnicodeDecodeError    | Unicode解码时的错误（UnicodeError的子类）                    |
  | UnicodeTranslateError | Unicode转换时的错误（UnicodeError的子类）                    |
  | ValueError            | 传入无效的参数                                               |
  | ZeroDivisionError     | 除数为零                                                     |

#### 4.1 异常处理

* 格式Ⅰ

  ```
  try: 	
  	正在执行的代码块 (执行时, 会不断的捕获异常) 
      
  except: 
  	处理异常
  ```

  ```
   异常演示
  # num = int(input('请输入一个数字: '))
  # 提示 ValueError, 代表 数值有误
  
  
  
  # 异常处理
  # try:
  # 	num = int(input('请输入一个数字: '))
  
  # 	print('您输入的数字为 %d' % num)
  
  # except:
  # 	print('您输入的不是数字, 请重新输入')
  ```

* 格式Ⅱ

  ```
  # 不同的错误, 报不同提示	
  try:
  	尝试的代码块
  	
  except 错误类型1:
  	处理方式1
   	
  except 错误类型2:
  	处理方式2
  ```

  ```
  # num = int(input('请输入能够被100除的数字:'))
  # res = 100 / num
  # print(' 100 / %d = %.2f ' % (num, res) )
  
  # try:
  # 	num = int(input('请输入能够被100除的数字:'))
  # 	res = 100 / num
  # 	print(' 100 / %d = %.2f ' % (num, res) )	
  # except ValueError:
  # 	print('您输入的不是数字')
  
  # except ZeroDivisionError:
  # 	print('除数不能为0')
  ```

* 格式III

  ```
  # 多个不同的错误, 报相同的信息	
  try:
  	代码块
  	
  except(错误类型1, 错误类型2, ...):
  	处理方法a
  
  except(错误类型3, 错误类型4, ...):
  	处理方法b
  ```

  ```
  try:
  	num = int(input('请输入能够被100除的数字:'))
  	res = 100 / num
  	print(' 100 / %d = %.2f ' % (num, res) )	
  
  	list1 = [10,20,30,40]
  	print(list1[99])
  
  	dict1 = {'name': '杨超越', 'sex': '女'}
  	print(dict1['age'])
  
  
  except (ValueError, ZeroDivisionError):
  	print('您输入的数字不正确')
  
  except (IndexError, KeyError):
  	print('您的索引or键 不存在或超过范围')
  ```

* 格式Ⅳ

  ```
  # 出现未知的错误, 可以进行统一处理
  try:
  	num = int(input('请输入能够被100除的数字:'))
  	res = 100 / num
  	print(' 100 / %d = %.2f ' % (num, res) )
  
  except Exception as error:
  	print('未知错误: %s ' % error )
  ```

* 格式

  ```
  # 	try:
  # 		代码块1
  # 	
  # 	except 错误类型1:
  # 		处理方法1
  # 	
  # 	except 错误类型2:
  # 		处理方法2:
  # 	
  # 	except (错误类型3, 错误类型4, ...)
  # 		处理方法3
  # 	
  # 	except (错误类型5, 错误类型6, ...)
  # 		处理方法4
  # 	
  # 	except Exception as 变量
  # 		处理方法5
  # 	
  # 	else:
  # 		没有异常时, 才会执行该代码块
  # 	
  # 	finally:
  # 		无论是否有异常, 都会执行该代码块
  ```



#### 4.2 主动抛出异常

* **① 场景**

  之前用的py解释器自己发现了错误, 自动抛出了异常

  实际开发中, 有些业务逻辑无法满足时, 但是没有触犯语法问题

  python不会自动报错, 只能我们自己 主动抛出异常

* ② 语法

  ```
  try:
  	raise Exception(自定义异常信息)
  	
  except Exception as 别名:
  	处理异常
  ```



### 5. 流程控制符

* continue

  立马结束当前一轮循环, 准备下一轮循环

* break

  立马结束循环, 准备执行 循环外的代码

* pass

  占位,为了防止python报错

* exit()

  程序一旦执行到 exit()时, 会立马终止程序

---


## 二十、函数



### 1. 定义一个函数

* **1.1 函数代码段以`def`关键字开头,后接函数表示符名称和圆括号()**

* **1.2 任何传入参数和自变量必须放在圆括号中间,圆括号之间可以用于定义参数**

* **1.3 函数的第一行语句可以选择性的使用文档字符串用于存放函数说明**

* **1.4 函数内容以冒号起始,并且缩进**

* **1.5 `return [表达式]`结束函数,选择性的返回一个值给调用方,不带表达式的return相当于返回None**

* **1.6 语法**

  ```
  def 函数名(参数列表):
  函数体
  ```



### 2. 函数的调用

* **函数名(参数)**
    ```
    def a():
        print(666)
    a()
    ```



### 3. 参数传递	

* **3.1 传递不可变对象(传值)**

    ```
    def num(a):
        a += 10
        return a
    b = 2
    print(num(b))
    print(b)
    => 12
    => 2
    ```


* **3.2传可变对象(传址)**

    ```
    def list1(a):
        a[0] += 10
        return a
    list2 = [1,2,3]
    print(list1(list2))
    print(list2)
    => [11, 2, 3]
    => [11, 2, 3]
    ```



### 4. 参数

* **4.1 位置参数**
两个参数的顺序必须一一对应，且少一个参数都不可以
* **4.2 关键字参数**
关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。
使用关键字参数允许函数调用时参数的顺序与声明时不一致.
* **4.3 默认参数**
调用函数时，如果没有传递参数，则会使用默认参数。
* **4.4 不定长参数**
    1) 加了星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。
    2) 加了两个星号 ** 的参数会以字典的形式导入。
    3) 如果单独出现星号 * 后的参数必须用关键字传入。

### 5. return
`rturn [表达式]` 语句用于退出函数，选择性地向调用方返回一个表达式。
不带参数值的**return语句返回None**。



### 5. 变量作用域

#### 5.1 全局/局部变量
* **全局变量**
在函数外部定义的变量,即为全局变量
* **局部变量**
只能在其被声明的函数内部访问在函数内部定义的变量,即为局部变量

#### 5.2 作用域
|       作用域       | 名词      | 简写 |
| :--------------: | :-------- | :--- |
|     局部作用域     | local     | L    |
| 闭包函数外的函数中  | enclosing | E    |
|     全局作用域     | global    | G    |
|     内建作用域     | built-in  | B    |

以L->E->G->B的规则查找,在局部找不到,会去局部外的局部找,再找不到就会去全局找,再则去内建作用域中找
#### 5.3 改变作用域

* **global**
在作用域E不能直接修改全局变量,在修改变量之前,同过global声明一下即可改变

* **nonlocal**
在作用域L中不能直接修改修改作用域E中的变量
>改变G中的变量 global
>改变E中的变量 nonlocal
>在 global nonlocal 声明变量之前,不能更改这个变量.


### 6. 闭包函数

#### 6.1定义

闭包就是能够读取其他函数内部变量的函数
* **函数A里面定义一个新的函数B**
* **在函数B中使用了函数A的变量**
> 只有满足以上两个条件,那么函数B即为闭包函数

#### 6.2 使用方式
* **直接调用**
在函数A直接调用函数B
```
def A():
    x = 10
    def B():
        y = 20
        y = x + y  # 在 B函数中使用函数 A 的变量 x 这时候 B 是闭包函数
        print(y)
    B()            # 直接调用 如果不执行B()  那么 不会去输出y
A()
=> 30
```
* **返回函数名**
```
def A():
	x=10
	def B():
		y=20
		y=x+y
		print(y)
	return B	# 返回 B 函数
res = A()	# 接收了 到了 return 的函数B
print(res)
res()
=> <function A.<locals>.B at 0x0033C420>
=> 30
```

#### 6.3 作用
* **优点: 数据的持久化**
* **缺点: 因为持久化,没有及时释放所以占内存**

#### 6.4 注意事项
> 闭包函数不能直接修改外部函数的局部变量


### 7. 匿名函数

#### 7.1 定义
​	**没有名字的函数,可当做表达式使用**

#### 7.2 格式
​	`lambda 形参:需要返回的结果`
​	冒号左边: **想要传递的参数**
​	冒号右边: **return想要的结果**

> 原理解析
> 相当于一个def

#### 7.3 作用
* **匿名函数仅适合不想取函数名,功能简单**
* **匿名函数可做表达式,并非语句,所以用在def不能用的地方**
### 8. 高阶函数

#### 8.1 定义

- **参数为函数**
- **返回值为函数**

> 满足以上任意一点, 即为高阶函数

#### 8.2 作用

- **易于可读性**
- **方便代码维护**
- **隔离作用域**

#### 8.3 高阶函数

- **1）map(def, iterable1, iterable2, ...)**
  功能:将可迭代对象中的每一个对象, 都是用一遍函数
  参数: 
  def: 内置函数或自定义函数
  iterable: 可迭代对象
  返回值: 对象

    ```
    # 需求:
    # 将 1 ~ 10 每一个值都开平方
    def power(x):
        return x ** 2

    for i in map(power, range(1,11) ):
        print(i)
    ```

- **2）filter( def, iterable)**
  功能: 过滤 可迭代对象中的数据, 保留符合条件的数据
  参数: 
  def: 内置函数 or 自定义函数
  iterable: 可迭代对象	
  返回值: 满足条件, 则返回对应的迭代数据, 不是返回bool

    ```
    # 需求:
    # 	以列表形式输出 1 ~ 10 之间的偶数

    def iseven(x):
        return x % 2 == 0

    a = list( filter(iseven, range(1,11)) )
    print(a)

    ```

- **3）sorted(iterable, reverse=False, key=None )**
  功能: 将可迭代对象进行排序, 生成排好的序列
  参数:
  iterable: 可迭代对象
  reverse: 
  False 	升序, 默认
  True 	降序
  key: 排序依据, 默认none
  返回值: 排好序后的 可迭代对象

    ```
    # 需求1:
    # 	按照 值的大小升序
    a = set('123456789')
    b = sorted(a)
    print(a,b)
    ```

- **4）reduce(def, iterable)**
  功能: 对可迭代对象的每一个对象进行累加操作
  参数: 
  def: 内置 or 自定义函数
  iterable: 可迭代对象  
  返回值: 累加之后的值

    ```
    from functools import reduce 	# 在使用reduce() 之前, 必须先导入该模块
    a = [1,2,3,4,5]
    def add(x,y):
        return x+y
    b = reduce(add, a)
    print(b)
    ```

------



---


## 二十一、容器

### 1. 容器嵌套

#### 1.1 列表嵌套

* **二维列表**
    ```
    a = [ 
            [],
            [],
            [],
            [] 
        ]
    ```
* **三维列表**
    ```
    a = [
            [
                [],
                [],
                [],
                []
            ],
            [
                [],
                [],
                [],
                []
            ]
        ]
    ```
* **多维列表的操作**
    ```
    a = [ 
            ['1', '2'],
            ['3', '4'],
            ['5', '6'],
            ['7', '8'] 
        ]

    print( a[3] )
    print( a[3][0] )
    => ['7', '8'] 
    => 7
    ```
>*说明:*
>若嵌套了一层, 可称之为 二维列表
>若嵌套了二层, 可称之为 三维列表
>依次类推
#### 1.2 元组嵌套

```
a = (
        ['1', '2'],
        ['3', '4'],
        ['5', '6'],
        ['7', '8'] 
    )
print( a[1][1]   )
a[1][1] = '光头强'
print( a[1][1]   )
=> 3
=> 光头强
```
#### 1.3 字典嵌套
```
a = {
        'name': ['小明', '小兰'],
        'age': [18, 28],
        'sex': ['女', '男'],
    }
print( a['name'][1] )
=> 小兰
```


### 2. 容器遍历

#### 2.1 list遍历
```
a = ['1', '2', '3', '4', '5']
i = 0
while i < 4:
    print(i, a[i],end=" ")
    i += 1
```
```
a = ['1', '2', '3', '4', '5']
# i 代表索引
for i in range(4):
    print(i, a[i], end=" ")
```
```
# 灵活遍历 列表值
a = ['1', '2', '3', '4', '5']
print( len(a) ) # 获取当前列表a 有几个值 (长度)
length = len(a)
for i in range( length ):
    print(i, a[i], end=" ")
```
```
a = ['1', '2', '3', '4', '5']
# i 代表值
# a.index(i)    获取值i 在a列表里面的索引
for i in a:
    print(a.index(i), i, end=" ")
```
#### 2.2 tuple遍历
```
a = ['1', '2', '3', '4', '5']
# i 代表索引
for i in range(5):
    print(i, a[i], end=" ")
```
```
a = ['1', '2', '3', '4', '5']
for i in range( len(a) ):
    print(i, a[i], end=" ")
```
```
a = ['1', '2', '3', '4', '5']
for i in a:
    print(a.index(i), i, end=" ")
```
#### 2.3 dict遍历
```
a = {'name':'关二哥', 'age':'56', 'sex':'男'}
for i in a:
    print(i, end=" ")       # i     代表 键
    print(a[i], end=" ")    # a[i]  代表 值
```
```
a = {'name':'关二哥', 'age':'56', 'sex':'男'}
# 专门获取键
for i in a.keys():
    print(i, end=" ")
```
```
a = {'name':'关二哥', 'age':'56', 'sex':'男'}
# 专门获取值
for i in a.values():
    print(i, end=" ")
```
```
a = {'name':'关二哥', 'age':'56', 'sex':'男'}
# 专门获取键和值
for i,j in a.items():
    print('i= %s' % i, end=" ")
    print('j= %s' % j)
```

#### 2.4 set遍历
```
a = {'醋', '可乐', '生姜汁', '芥末汁', '苦瓜汁', '黑啤'}
for i in a:
    print(i, end=" ")
```
#### 2.5 多维容器遍历
```
a = [
        ['1','2','3'],
        ['4','5','6'],
        ['7','8','9'],
    ]
for i,j,k in a:
    print(k, end=" ")
=> 3 6 9
```
```
a = {
        'name': ['姬发', '妲己'],
        'sex': ['男','女'],
        'age': [18, 28]
    }
for i,j in a.items():
    print(i, end=" ")
    print(j)
```
```
for i,j in a.items():
    for x in j:     # j 是每一个键后面对应的 列表
        print(x)
```
---


##  二十二、推导式

### **一. 列表推导式**

#### 1. 基本推导式
* **格式:**	`[ 变量操作 for 变量 in 容器]`
* **返回值: 新的容器**
* **分析:**
  **变量: 每次从容器 获取一个值**
  **变量操作: 将得到的变量 进行操作, 操作的结果给 列表**

#### 2. 条件推导式
* **格式:**

  `[ 变量操作 for 变量 in 容器 if 条件 ]`

  `[ true环境 if 条件 else false环境 for 变量 in 容器 ]`
#### 3. 多循环推导式
* **格式:**

  `[ 变量操作 for 变量1 in 容器1  for 变量2 in  容器2 ]`
#### 4. 多循环条件推导式
* **格式:** 

   `[ 变量操作 for 变量1 in 容器1  for 变量2 in  容器2 if 条件]`

   `[ true环境 if 条件 else false环境 for 变量1 in 容器1 for 变量2 in 容器2 ]`
### 二. 字典推导式
#### 1. 基本推导式
* **格式:**	

  `{ 键:值 for 键,值 in 字典.items() }`
#### 2. 条件推导式
* **格式:**

  `{ 键:值 for 键,值 in 字典.items() if 条件}`
#### 3. 多循环推导式
* **格式:**	

  `{ 键:值 for 键1,值1 in 字典1.items() for 键2,值2 in 字典2.items() }`

#### 4. 多循环条件推导式
* **格式:**	

  `{ 键:值 for 键1,值1 in 字典1.items() for 键2,值2 in 字典2.items() if 条件 }`
### 三. 集合推导式
#### 1. 基本推导式
* **格式:**

  `{ 变量操作 for 变量 in 集合 }`

#### 2. 条件推导式
* **格式:**	

  `{ 变量操作 for 变量 in 集合 if 条件 }`
#### 3. 多循环推导式
* **格式:**	

  `{ 变量操作 for 变量1 in 集合1 if 条件 for 变量2 in 集合2 }`
#### 4. 多循环条件推导式
* **格式:**	

  `{ 变量操作 for 变量1 in 集合1  for 变量2 in 集合2 if 条件}`
---



## 二十三、迭代器

### 1. 可迭代对象iterable
 够被for循环遍历的容器 都是可迭代对象
> 能迭代的对象: list, tuple, dict, set, range, 生成器等
```
from collections import Iterable	# 导入 Iterable模块
# isinstance() 来检测是否为 可迭代对象
print( isinstance([], Iterable)   )
print( isinstance((), Iterable)   )
print( isinstance({}, Iterable)   )
print( isinstance(set(), Iterable)   )
print( isinstance(range(10), Iterable)   )
print( isinstance(10, Iterable)   )
print( isinstance('abc', Iterable)   )
```
### 2. 迭代器iterator
将可迭代对象一个一个的获取出来

* 创建迭代器 iter()

    ```
    a=iter([1,2,3,4])
    print(a)
    ```
* 迭代可迭代对象next()

    ```
    print(next(a))
    print(next(a))
    print(next(a))
    print(next(a))
    ```
* 小结:
> 迭代器是需要用时,才去拿一个,人称:懒加载
> 循环是一旦开始,就必须把对象中的数据全部拿出来
---



## 二十四、生成器

### 1. 生成器 generator
> 列表推导式,可以直接创建一个新的列表,一旦数据量过大,必然会受到内存的限制.此时只需要用到其中几个数据,就太浪费内存和性能
> 最佳方法:通过算法,一边循环,一边计算,要多少那多少,不要不生成
> 既满足推导式,又节省了空间(避免一次性生成整个列表)

> 生成器就是迭代器
迭代器不是生成器

###  2. 分类
#### 2.1 生成器表达式
* 格式:
 生成器对象 = (变量操作 for 变量 in 容器)
    ```
    a = ( 2**i for i in range(10) )
    print(a)
    => <generator object <genexpr> at 0x01D8EE30>
    ```
* 返回值: 
生成器对象,并非元组
> 说明:
形式推导式,将推导式[]转成(),可以当做元组推导式,但python没有元组推导式
* 获取生成器中的值:
方法1:next(生成器)
方法2:生成器.__next__()
#### 2.2 函数生成器
* 定义:
包含 关键字yield 的函数就是生成器
* 执行原理:
在生成器执行过程中, 遇到 yield就会立马中断并return yield所修饰的变量.
当再次调用生成器时, 会接着上一次的中断点后继续执行
    ```
    def test():
        i = 0
        while i < 5:
            yield i 	# return i
            i += 1
    ```

### 3. 迭代生成器
生成器 也是 可迭代对象之一

### 4. 传参
每次**yield**立马返回变量 i , 下一次迭代 res = None了
能否在下一次迭代时, 传入参数, 以保证 res 不等于 None
在下一次迭代时, 通过 send() 方法传入参数

```
def test():
	i = 0
	while i < 5:
		res = yield i 	 	# return i 	一旦返回后 res = None 空
		print(res)
		i += 1
a = test()
print( next(a) ) 
print( next(a) ) 
print( a.send('hello'))
print( next(a) ) 
```
### 5. 迭代器和生成器的区别
>生成器 肯定是 迭代器
迭代器 不一定是 生成器
* 迭代器: 仅仅为了将 可迭代对象中的值 一个一个获取出来
* 生成器: 通过 算法一个一个计算并创造出来, 且能终止函数, 将参数传入生成器, 最后接着中断点 继续向后执行
---





## 二十五、模块

### 1. 定义
在实际开发中, 有一些功能会被多个不同的文件所使用.
为了避免多次复制, 可将这些功能写入模块, 这样哪个文件需要, 就引入该模块即可
每一个py文件都可以当做模块  	(其他模块文件有: xxx.pyc   xxx.pyo   xxx.dll  xxx.pyd   xxx.so)
模块可以包含变量, 函数 和 可执行的语句 等代码

### 2.分类
#### 2.1 开源模块
常见有趣的模块: 爬虫, 数据分析, 数据处理, 机器学习 等	
开源模块地址: https://pypi.org/
游戏模块地址: http://www.pygame.org/
#### 2.2 内置模块
python自带的内置模块, 例如: string模块, math模块, random模块, time模块 

#### 2.3自定义模块
根据客户需求, 自己编辑py文件,形成一个模块, 供给其他人使用

### 3. 引入模块(整个模块)
* 格式:
	`import 模块1` 
	`import 模块2`
	`import 模块1, 模块2, 模块3, ...`
* 注意:
每一个import 都是独占一行

使用模块的工具:
​	模块名.变量名 		这里的变量名 称之为 属性名
​	模块名.函数名() 		这里的函数名 称之为 方法名

```
# 引入 内置模块string
import string
print(string.ascii_letters)

# 引入 自定义模块test
import test
print(test.name)
print(test.demo())
```
### 4. 局部引入
* 格式:
	`from 模块1 import 工具名`
局部引入后, 就不需要再声明前缀(哪个模块), 可以直接使用
```
from test import demo
print( demo() )
```


### 5. 别名

* 格式:
	`import 模块1 as 别名`
```
import test as T 
print(T.name)
print(T.demo())
from test import demo as D
print( D() )
```


### 6.同名引入

由于 from ... import 引入, 不需要前缀, 可能会导致引入不同模块的 相同工具名.
此种情况, 会发生后面的模块 会覆盖前面的模块

* 解决方案: 
  给相同的工具名 取不同的别名

```
from test import demo as D
from test2 import demo 
print( demo() )
print( D() )

```



### 7.模块引入路径

#### 7.1 引入

python会从以下几个目录 来查找模块:

- **当前目录**
- **主程序目录\Dlls              python解释器的安装目录**
- **主程序目录\Lib**
- **主程序目录**
- **主程序目录\Lib\site-packages**

```
import sys      # 引入系统模块
print(sys.path)
```

#### 7.2 file__属性

- **获取当前文件路径 or 引入模块的路径**
  `print( __file__ )`

#### 7.3 __name__属性

**获取当前文件的名字 or 引入模块的名字**
`print( __name__ )`

> 若是当前文件, 则返回 `__main__`, 同时证明当前文件就是 正在运行的主程序
> 若是引入的模块, 则返回 模块名, 同时证明当前文件是 别人引入的模块

---



## 二十六、面向对象 OOP

### 1. 概念

> OOP 只是一种编程思想

- 类: 就是一个抽象, 虚拟的的事物
- 对象: 就是真实, 实际的对象



### 2. 类

- 定义

  ```
  class 类名():
      属性(有什么)
      方法(会什么)
  ```

  - 类名:
    1. 大驼峰命名法
    2. 名词
    3. 严格区分大小写
  - 属性名:
    1. 由数字,字母和下划线组成
    2. 不能以数字开头
  - 方法名:
    1. 小写,下划线命名法
    2. 动词+名词

- 注意:
  类一旦定义, 就会占据一个内存
  类不实例化, 则不能正常使用



### 3. 对象

- 3.1 实例化对象
  格式: 对象 = 类名()
- 3.2 通过对象使用属性
  格式: 对象.属性名
- 3.3 通过对象使用方法
  格式: 对象.方法名()

> 从同一个类实例化出来的对象, 内存各不一样, 对象互不影响



### 4. OOP特性

OOP 三大特性: **封装性**, **继承性**, **多态性**

#### 	4.1 封装性

- ① 定义:
  主要负责保护数据隐私 和 隔离复杂度
- ② 保护数据的隐私
  只要数据不能被外界所获取, 就能起到保护的数据的作用

```
私有属性: __属性名
私有方法: __方法名()
```

*  ③ 注意:
    在python中,没有完全意义上的私有化,通过特殊方式,能在外界获取私有属性

```
class Demo():
    __name = '二狗'

    def __skill(self):
        print('阴阳狗')
# 外界
dog = Demo()
# print( dog.__name ) #报错
print( dog._Demo__name )    # 特殊访问方式
```

> 在实际开发中,千万不要如此获取,否则就失去了私有的意义

#### 	4.2 继承性

子类继承父类的一些属性和方法

- 定义
  主要负责类的继承, 扩展, 降低代码的冗余率(代码重复度)
- 格式

```
class 子类名(父类名):
    代码块
```

- 特性

  1. 可以继承属性和方法 (不能继承私有属性和方法)

  2. 可以重写属性和方法
  3. 扩展父类
  4. 支持单继承, 连续继承, 多继承

**4.2.1 单继承**
​	一个子类只继承一个父类

**4.2.2连续继承**

**4.2.3多继承**

- 格式:` class 子类(父类1, 父类2, 父类3, ...)`

- 继承冲突:
  当继承发生冲突时,采用就近原则,先继承谁,就继承谁的属性和方法(在实际开发中, 尽量避免此种情况发生, 容易混淆)

- 继承顺序:
  当多继承较多时, 可通过 __mro__ 来查看继承顺序
  使用格式:`类名.__mro__`

- 发现:

  继承中, 所有的类最终都会继承object

  在祖辈类 object中, 提供实例化的方法

#### 4.3 多态性

* 定义: 通过同一个类 , 传入不同的对象,从而实现不同的效果
* 有点: 提高代码的灵活度



### 5. 伪对象

* 定义:

  伪对象可以在当前类内 操作使用属性和方法

* self : 

  self代表类的实例，而非类

  1. 位置: 设在每个方法中参数的第一个位置

  2. 命名: 常用命名self, 可以修改命名

  3. 格式:

     ```
     self.属性名
     
     self.方法名()
     ```

  4. 创建属性 (共享)

     在某方法内, 通过self.属性名 = 值

     该属性已存在, 则为 修改属性

     该属性不存在, 则为 创建属性

  5. 注意:

     self 相当于当前独享

     self的内存地址 与 对象内存地址相同



### 6. 构造方法

* 方法名:  `__init__` 

* 触发条件: 在实例化时, 自动调用

* 主要作用: 初始化属性

  * 给 `__init__ `传递参数:

    ```
    对象 = 类名(参数)
    ```

* 位置: 构造一般写在属性的最后面, 方法的最前面



### 7. 析构方法

* 方法名: `__del__`

* 触发条件 : ① 在对象被销毁时, 会自动触发

  ​		      ② 当前文件全部执行完时

  ​		      ③ 对象被覆盖时

  ​		      ④ 对象被删除时

* 主要作用 : 在对象结束时, 做结尾操作

* 位置 : 析构一般写在方法的最后面

---



## 二十七、文件操作

> 在计算机中, 基本文件操作就三步:
> 1. 打开文件
>
> 2. 操作文件(读/写)
>
>    读: 将文件中的内容读取出来
>
>    写: 增删改文件内容
>
> 3. 关闭文件

### 1. 打开文件

* open(文件路径, 打开模式, 本地编码)

* 返回值: 文件对象, 文件句柄



### 2. 写文件

* w模式:

  指针指向开头, 重写内容(删除原来的内容)

  文件不存在, 则自动创建

* 文件句柄.write(内容)		

* 返回值: 内容长度



### 4. 读文件

* r模式

  指针指向开头, 读取内容

  文件不存在, 则报错

* 返回值: 读取的内容



### 5. 追加文件

* 文件句柄 = open('文件路径', 'a')

* a模式

  指针指向末尾, 写入内容(不会删除原来的内容)

  文件不存在, 则自动创建

* 文件句柄.write(内容)



### 6. 增强模式

* +模式

  同时具备读写能力, 配合 rwa 使用(r+,w+,a+)

* 以r模式打开, 做写操作, 违反权限

  以w模式打开, 做读操作, 违反权限

* 以a+模式, 做读操作, 可以执行

  以r+模式, 做写操作, 可以执行

> 注: 由于r+ 模式, 指针指向开头, 再次写入时, 会从开头依次写入, 会覆盖原有位置的内容



### 7. 关闭文件

* 文件句柄.close()
* 释放内存



### 8. 序列写入

* 文件句柄.writelines(序列)
* 将序列中的值一个一个写入文件



### 9. 读取一行内容

* 文件句柄.readline(位数)
* 返回值: 字符串



### 10. 读取所有内容

* 文件句柄.readlines()
* 返回值: 列表



### 11. 截取内容

* 文件句柄.truncate(字节)
* 作用: 保留截取的内容, 删除剩余的内容
* 返回值: 截取的字节



### 12. 缓冲区

* 文件句柄.flush()

* 原理:

  wirte写操作 -> 内容 -> 缓冲区 -> flush -> 文件

* 自动刷新缓冲区:

  1) 整个程序结束时, 自动刷新缓冲区

  2) 文件关闭时, 自动刷新缓冲区

  3) 当缓冲区写满时, 自动刷新缓冲区

### 13. with 

> 自动关闭文件

* 格式:

  ```
  with 打开文件 as 句柄:
  	文件操作(代码块)
  	
  # 当代码块执行结束时, 句柄.close() 会自动执行
  ```

---



## 二十八、正则

### findall()

```
import re

string="abcdefg  acbdgef  abcdgfe  cadbgfe"

#带括号与不带括号的区别
#不带括号
regex=re.compile("((\w+)\s+\w+)")
print(regex.findall(string))
#输出：[('abcdefg  acbdgef', 'abcdefg'), ('abcdgfe  cadbgfe', 'abcdgfe')]

regex1=re.compile("(\w+)\s+\w+")
print(regex1.findall(string))
#输出：['abcdefg', 'abcdgfe']

regex2=re.compile("\w+\s+\w+")
print(regex2.findall(string))
#输出：['abcdefg  acbdgef', 'abcdgfe  cadbgfe']
```

> **findall()函数返回的总是正则表达式在字符串中所有匹配结果的列表list，此处主要讨论列表中“结果”的展现方式，即findall中返回列表中每个元素包含的信息。**

* 1.当给出的正则表达式中带有多个括号时，列表的元素为多个字符串组成的tuple，tuple中字符串个数与括号对数相同，字符串内容与每个括号内的正则表达式相对应，并且排放顺序是按括号出现的顺序。

* 2.当给出的正则表达式中带有一个括号时，列表的元素为字符串，此字符串的内容与括号中的正则表达式相对应（不是整个正则表达式的匹配内容）。

* 3.当给出的正则表达式中不带括号时，列表的元素为字符串，此字符串为整个正则表达式匹配的内容。



## 二十九、PyMySQL

[Python3 MySQL 数据库连接](http://www.runoob.com/python3/python3-mysql.html)

### 1. PyMySQL安装

```
pip install pymysql
```

### 2. 连接数据库

> 通过如下代码测试数据库连接

```python
 import pymysql
 
 # 打开数据库连接
 db = pymysql.connect("localhost","root","123456","mydb" )

 # 使用 cursor() 方法创建一个游标对象 cursor
 cursor = db.cursor()

 # 使用 execute()  方法执行 SQL 查询 
 cursor.execute("SELECT VERSION()")

 # 使用 fetchone() 方法获取单条数据.
 data = cursor.fetchone()

 print ("Database version : %s " % data)

 # 关闭数据库连接
 db.close()
```

### 3. 执行数据添加

```python
import pymysql

# 打开数据库连接
db = pymysql.connect("localhost","root","123456","mydemo" )

# 使用 cursor() 方法创建一个游标对象 cursor
cursor = db.cursor()

# SQL 插入语句
sql = "INSERT INTO stu(name,sex,age,classid) values('%s','%c','%d','%s')" % ('uu142','m',22,'lamp180') 

try:
   # 执行sql语句
   cursor.execute(sql)
   # 执行sql语句
   db.commit()
   print("ok: %d " % (cursor.rowcount))
except:
   # 发生错误时回滚
   db.rollback()

# 关闭数据库连接
db.close()
```

### 4. 执行删除操作

```python
 import pymysql

 # 打开数据库连接
 db = pymysql.connect("localhost","root","","mydemo" )

 # 使用 cursor() 方法创建一个游标对象 cursor
 cursor = db.cursor()

 # SQL 删除语句
 sql = "delete from stu where id = '%d'" % (13)
 try:
    # 执行SQL语句
    cursor.execute(sql)
    # 提交修改
    db.commit()
 except:
    # 发生错误时回滚
    db.rollback()

 # 关闭数据库连接
 db.close()
```

### 5. 执行数据修改/更新

```python
import pymysql

# 打开数据库连接
db = pymysql.connect("localhost","testuser","test123","TESTDB" )

# 使用cursor()方法获取操作游标 
cursor = db.cursor()

# SQL 更新语句
sql = "UPDATE EMPLOYEE SET AGE = AGE + 1
                          WHERE SEX = '%c'" % ('M')
try:
   # 执行SQL语句
   cursor.execute(sql)
   # 提交到数据库执行
   db.commit()
except:
   # 发生错误时回滚
   db.rollback()

# 关闭数据库连接
db.close()
```

### 6. 执行数据查询

> Python查询Mysql使用 fetchone() 方法获取单条数据, 使用fetchall() 方法获取多条数据。
>
> fetchone(): 该方法获取下一个查询结果集。结果集是一个对象
>
> fetchall(): 接收全部的返回结果行.
>
> rowcount: 这是一个只读属性，并返回执行execute()方法后影响的行数。

```python
 import pymysql

 # 打开数据库连接
 db = pymysql.connect("localhost","root","","mydemo" )

 # 使用 cursor() 方法创建一个游标对象 cursor
 cursor = db.cursor()

 # SQL 查询语句
 sql = "select * from stu limit %d" % (3)
 #sql = "select * from stu"

 try:
    # 执行SQL语句
    cursor.execute(sql)
    # 获取所有记录列表
    results = cursor.fetchall()
    for row in results:
       id = row[0]
       name = row[1]
       sex = row[2]
       age = row[3]
       classid = row[4]
        # 打印结果
       print ("id=%d,name=%s,sex=%s,age=%d,classid=%s" % (id,name,sex,age,classid))
 except:
    print ("Error: unable to fetch data")

 # 关闭数据库连接
 db.close()
```



# Python 爬虫



## 一、爬虫五个步骤

> 1.需求分析,确定url
>
> 2.发起请求
>
> 3.获取响应内容 **(urllib, requests)**
>
> 4.解析数据**(re, XPATH, jsonpath, bs(css selector))**
>
> 5.储存数据**(MySQL)**

---



## 二、HTML概述和基本结构

### 1. 网页的组成

* 网页由三部分组成

  ```
  html: 结构层，主要负责页面的结构
  css:  表现层，主要负责网页的样式
  javascrapy: 行为层，主要负责用户的动态交互
  ```



### 2. HTML基本结构

HTML是由：标签和内容构成

> `<title>这是文档中的标题</title>`

HTML标签（标记）的语法：

> 标签是由"<"和">"括起来
>
> 双标签：<标签名>....</标签名>
>
> 单标签：<标签名/>

```html
<!DOCTYPE html>
<!-- 这是一段注释  -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>网页标题</title>
</head>
<body>
    网页显示内容
</body>
</html>
```



### 3. HTML常用标签

* 标题标签

  ```
  h1~h6
  ```

* 段落标签,换行符，实体字符

  ```
  段落标签p
  换行符 <br>
  实体字符 &lt; &gt;
  ```

* 块标签：

  ```
  div 没有默认样式 一般配合css使用做网页的布局
  ```

* 图片标签

  ```
  <img src="">
  src 是属性 用于连接图片的地址
  ```

* 音频标签

  ```
  <audio src=""></audio>
  ```

* 视频标签

  ```
  &lt;video src=&quot;&quot;&gt;&lt;/video&gt;
  ```

* 链接标签

  ```
  <a href="">内容</a>
  href属性 跳转地址
  ```

* 表格标签

  ```
  table 声明一个表格
  tr 行
  td 列
  
  属性：
        1、border 定义表格的边框
  
        2、cellpadding 定义单元格内内容与边框的距离
  
        3、cellspacing 定义单元格与单元格之间的距离
  
        4、align 设置单元格中内容的水平对齐方式,设置值有：left | center | right
  
        5、valign 设置单元格中内容的垂直对齐方式 top | middle | bottom
  
        6、colspan 设置单元格水平合并
  
        7、rowspan 设置单元格垂直合并
  ```

* 列表：

  ```
  ul>li 无须列表
  ol>li 有序列表
  dl>dt>dd 自定义列表
  ```

* 表单：

  ```
  from 声明一个表单域
     属性： action  提交地址
           method   请求方式
  
  <form action="http://www..." method="get">
  
  ...
  
  </form>
  ```



### 4. HTML节点树

![](2-12.jpg)



> 节点树中，顶端节点为根节点，除了根节点每个节点都有父节点，同时也拥有多个子节点和兄弟节点

---



## 三、网络简介

### 1. 网络模型:

| 实际应用四层模型  | 理论七层网络模型: |
| ----------------- | ----------------- |
| 链路层/网络接口层 | 物理层            |
| 网络层            | 数据链路层        |
| 传输层            | 网络层            |
| 应用层            | 传输层            |
|                   | 会话层            |
|                   | 表示层            |
|                   | 应用层            |

### 2. IP地址

> 地址是用来标记地点的
>
> 每一个IP地址都包括两部分：网络地址和主机地址

* A类IP地址

  ```
  一个A类地址由1字节的网络地址和3字节主机地址组成，
  网络地址最高位必须是0
  地址范围1.0.0.1-126.255.255.254
  可用的A类网络有126个，每个网络能容纳1677214个主机
  ```

* B类IP地址

  ```
  一个B类地址由2个字节的网络地址和2个字节的主机地址组成,
  网络地址最高位必须是01
  地址范围128.1.0.1-191.255.255.254
  可用的B类网络有16384个，每个网络能容纳65534个主机
  ```

* C类IP地址

  ```
  一个C类地址由3个字节的网络地址和1个字节的主机地址组成，
  网络地址最高位必须是110
  地址范围192.0.0.1-223.255.255.254
  可用网络有2097152个，每个网络能容纳254个主机
  ```

* D类IP地址多用于多点广播

  ```
  D类IP地址第一个字节由1110开始，他是专门保留的地址。
  他并不指向特定的网络，目前这一类地址备用在多点广播中
  多点广播地址用来一次寻址一组计算机
  地址范围224.0.0.1-239.255.255.254
  ```

* E类IP地址

  ```
  以1111开始，为将来使用保留
  E类地址保留，仅实验和开发用
  ```

* 注意

  ```
  IP地址127.0.0.1-127.255.255.255用于回路测试，如：127.0.0.1可以代表本机IP，
  用http://127.0.0.1就可以测试本机配置的WEB服务
  ```



### 3. 端口

* **端口号**

  > 端口号是通过端口来标记的，范围是从0-65535

* **分类**

  > 不是随意使用的，而是按照一定的规定进行分配的
  >
  > 端口号的分类有好几种，我们只介绍知名端口好和动态端口号



  #### 知名端口

  ```
  知名端口是众所周知的端口号，一般是从0-1023
  80端口分配给HTTP服务
  21端口分配给FTP服务
  ```

  #### 动态端口

  ```
  动态端口的范围一般是从1024到65535
  之所以称之为动态端口，是因为它一般不固定分配某种服务，而是动态分配。
  动态分配是指当一个系统进程或者应用程序进程需要网络通讯时，它向主机申请一个端口，主机从可用的端口号中分配一个供它使用
  当这个进程关闭时，同事也就释放了所占用的端口号
  ```

### 4. UDP协议

* UDP：

  > 用户数据报协议，不可靠性，
  >
  > 只是把应用程序传给IP层数据报送出去，不能保证他们是否能到达目的地,
  >
  > 传输数据报前不用在客户端和服务器之间建立连接，
  >
  > 并且没有超时重发机制，所以传输速度快。

* 特点：

  > 安全性差，传输速度快，无序，大小有限制64kb



   **socket--UDP网络通讯**

* 服务端：

  ```
  1.创建套接字对象
  2.绑定ip地址和端口号
  3.接受消息
  4.返回消息
  5.关闭套接字
  
  import socket
  # 创建套接字
  udp_s = socket.socked(socket.AF_INET,socket.SOCK_DGRAM)
  # 绑定ip地址
  udp_s.bind(('',8080))
  # 接受消息
  data,addr = udp_s.recvfrom(1024)
  print(data)
  
  # 关闭套接字
  udp_s.close()
  ```

* 客户端：

  ```
  1.创建套接字对象
  2.发送消息
  3.关闭套接字对象
  
  import socekd
  # 创建套接字对象
  udp_c = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
  # 发送消息
  udp_c.sendto('hello'.encode('utf-8'),('192.168.1.15',8080))
  # 关闭套接字
  udp_c.close()
  ```



### 5. TCP协议

* TCP

  > 在通讯之前，一定要先建立相关链接，才能发送数据

* 特点

  > 安全性高，稳定性好，有序 速度相对较慢

* 建立连接 三次握手

  ```
  ACK：确认标志
  SYN：同步标志
  第一次握手：主机A发送位码为syn＝1,随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机；
  
  第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1),syn=1,ack=1,随机产生seq=7654321的包
  
  第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功。
  
  完成三次握手，主机A与主机B开始传送数据。
  ```



   **Socket--TCP网络通讯**

* 服务端：

  ```
  1.创建套接字对象
  2.绑定ip地址和端口号
  3.监听
  4.接受消息
  5.返回消息
  6.关闭套接字
  
  import socket
  tcp_s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
  tcp_s.bind(('',8080))
  tcp_s.listen()
  s,addr = tcp_s.accept()
  data = s.recv(1024)
  print(data.decode('utf-8'))
  s.send('hello'.encode('utf-8))
  s.close()
  tcp_s.close()
  ```

* 客户端：

  ```
  1.创建套接字对象
  2.创建连接
  3.发送消息
  4.关闭套接字对象
  
  import socket
  tcp_c = socket.socket(socket.AF_INET,socket.SOCK_STRAM)
  tcp_c.connect(('192.168.1.15',8080))
  tcp_c.send('hello'.encode('utf-8'))
  tcp_c.close()
  ```



### 6. HTTP简介

> HTTP协议主要工作在客户端-服务端的架构上，浏览器作为HTTP客户端通过URL向HTTP服务端即 WEB服务器发送请求，服务器根据接受到的请求，向客户端发送相应信息

* **超文本传输协议**

  是一种按照URL指示，将超文本文档从一台主机(Web服务器)传输到另一台主机(浏览器)的应用层协议，以实现超链接的功能。

* **超文本（Hyper Text）**

  包含有超链接(Link)和各种多媒体元素标记(Markup)的文本。这些超文本文件彼此链接，形成网状(Web)，因此又被称为网页(Web Page)。这些链接使用URL表示。最常见的超文本格式是超文本标记语言HTML。

* **URL**

  URL即统一资源定位符(Uniform Resource Locator)，用来唯一地标识万维网中的某一个文档。URL由协议、主机和端口(默认为80)以及文件名几部分构成。

  ```
  例：http://www.aspxfans.com:8080/news/index.asp?boardID=5ID=24618page=1#name
  一个完整的URL包括以下几个部分
  1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在"HTTP"后面的“//”为分隔符
  
  2.域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用
  
  3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口
  
  4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”
  
  5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名
  
  6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分
  
  7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5ID=24618page=1”。参数可以允许有多个参数，参数与参数之间用“”作为分隔符。
  ```



### 7. HTTP原理

* **请求响应模型**

  在用户点击URL,浏览器和服务器会执行哪些动作

  - 1.浏览器分析超链接中的URL
  - 2.浏览器向DNS请求解析www.sxtyu.com的IP地址
  - 3.DNS将解析出的IP地址202.2.16.21返回浏览器
  - 4.浏览器与服务器建立TCP连接(80端口)
  - 5.浏览器请求文档：GET /index.html(发送HTTP请求)
  - 6.服务器给出响应，将文档 index.html发送给浏览器
  - 7.释放TCP连接
  - 8.浏览器显示index.html中的内容

* **连接方式**

  - 1.非持久性连接
  - 2.持久性连接

* **无状态性**

  是指同一个客户端(浏览器)第二次访问同一个Web服务器上的页面时，服务器无法知 道这个客户曾经访问过。HTTP的无状态性简化了服务器的设计，使其更容易支持大量并发的HTTP请求。


### 8. HTTP请求报文

> 即从客户端(浏览器)向Web服务器发送的请求报文。报文的所有字段都是ASCII码。

* **请求报头中的方法**
  - HEAD 类似GET请求，只不过返回的响应中没有具体内容，用于获取报头
  - PUT 从客户端向服务器传送的数据取代指定文档中的内容
  - DELETE 请求服务器删除指定的页面
  - CONNECT 把服务器当作跳板，让服务器代替客户端访问其他网页
  - OPTIONS 允许客户端查看服务器的性能
  - TRACE 回显服务器收到的请求，主要用于测试或诊断

* **请求头部**

  Accept：

  > 请求报头域，用于指定客户端可接受哪些类型的信息。

  Accept-Language：

  > 指定客户端可接受的语言类型。

  Accept-Encoding：

  > 指定客户端可接受的内容编码。

  Host：

  > 用于指定请求资源的主机IP和端口号，其内容为请求URL的原始服务器或网关的位置。 从HTTP 1.1版本开始，请求必须包含此内容。

  Cookie：

  > 也常用复数形式 Cookies， 这是网站为了辨别用户进行会话跟踪而存储在用户本地的数据。 它的主要功能是维持当前访问会话。 例如，我们输入用户名和密码成功登录某个网站后，服务器会用会话保存登录状态信息 ，后面我们每次刷新或请求该站点的其他页面时， 会发现都是登录状态，这就是Cookies的功劳。 Cookies里有信息标识了我们所对应的服务器的会话， 每次浏览器在请求该站点的页面时，都会在请求头中加上Cookies并将其发送给服务器， 服务器通过Cookies识别出是我们自己，并且查出当前状态是登录状态， 所以返回结果就是登录之后才能看到的网页内容。

  Referer：

  > 此内容用来标识这个请求是从哪个页面发过来的， 服务器可以拿到这一信息并做相应的处理，如作来源统计、防盗链处理等。

  User-Agent：

  > 简称UA，它是一个特殊的字符串头，可以使服务器识别客户使用的操作系统及版本、浏览器及版本等信息。 在做爬虫时加上此信息，可以伪装为浏览器；如果不加，很可能会被识别出为爬虫。

  Content-Type：

  > 也叫互联网媒体类型（Internet Media Type）或者MIME类型， 在HTTP协议消息头中，它用来表示具体请求中的媒体类型信息。 例如，text/html代表HTML格式，image/gif代表GIF图片， application/json代表JSON类型。

  更多对应关系可以查看此对照表：<http://tool.oschina.net/commons。>

* **请求体**

  > 请求体一般承载的内容是POST请求中的表单数据，而对于GET请求，请求体则为空。 
  >
  > 设置Content-Type为application/x-www-form-urlencoded，以表单数据的形式提交 Content-Type设置为application/json来提交JSON数据，或者设置为multipart/form-data来上传文件 在爬虫中，
  >
  > 如果要构造POST请求，需要使用正确的Content-Type，并了解各种请求库的各个参数设置时使用的是哪种Content-Type，不然可能会导致POST提交后无法正常响应。



### 9. HTTP响应报文

> 即从Web服务器到客户机(浏览器)的应答。报文的所有字段都是ASCII码。

* **响应报文中的状态码**

  状态码(Status-Code)是响应报文状态行中包含的一个3位数字，指明特定的请求是否被满足，如果没有满足，原因是什么。状态码分为以下五类：

  - 1xx：指示信息--表示请求已接收，继续处理。
  - 2xx：成功--表示请求已被成功接收、理解、接受。
  - 3xx：重定向--要完成请求必须进行更进一步的操作。
  - 4xx：客户端错误--请求有语法错误或请求无法实现。
  - 5xx：服务器端错误--服务器未能实现合法的请求。

  常见状态代码、状态描述的说明如下:

  ```
  200 OK：客户端请求成功。
  400 Bad Request：客户端请求有语法错误，不能被服务器所理解。
  401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。
  403 Forbidden：服务器收到请求，但是拒绝提供服务。
  404 Not Found：请求资源不存在，举个例子：输入了错误的URL。
  500 Internal Server Error：服务器发生不可预期的错误。
  503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。
  ```

* **响应头**

  Date：

  > 标识响应产生的时间。

  Last-Modified：

  > 指定资源的最后修改时间。

  Content-Encoding：

  > 指定响应内容的编码。

  Server：

  > 包含服务器的信息，比如名称、版本号等。

  Content-Type：

  > 文档类型，指定返回的数据类型是什么，如text/html代表返回HTML文档，application/x-javascript则代表返回JavaScript文件，image/jpeg则代表返回图片。

  Set-Cookie：

  > 设置Cookies。响应头中的Set-Cookie告诉浏览器需要将此内容放在Cookies中，下次请求携带Cookies请求。

  Expires：

  > 指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。如果再次访问时，就可以直接从缓存中加载，降低服务器负载，缩短加载时间。

* **响应体**

  > 响应的正文数据都在响应体中，比如请求网页时，它的响应体就是网页的HTML代码；请求一张图片时，它的响应体就是图片的二进制数据。我们做爬虫请求网页后，要解析的内容就是响应体



### 10. HTTP代理

> HTTP代理又称Web缓存或代理服务器(Proxy Server),是一种网络实体， 能代表浏览器发出HTTP请求，并将最近的一些请求和响应暂存在本地磁盘中， 当请求的Web页面先前暂存过，则直接将暂存的页面发给客户端(浏览器)，无须再次访问Internet。

---



## 四、虚拟环境virtualenv

>Virtualenv用于在一台机器上创建多个独立的python环境
>
>可以让每一个python项目单独使用一个环境，而不会影响python系统环境，也不会影响其他环境
>
>可以隔离项目之间三方包的依赖

* **安装**

  > pip install virtualenv

* **创建虚拟环境**

  > 在命令行里执行 virtualenv v1

* **激活虚拟环境**

  进入到v1中的Scripts目录下

  > 执行 activate

  命令行前面会多一个（v1）说明已经在虚拟环境中

* **退出虚拟环境**

  > deactivate

* **pip的使用技巧 freeze**

  当我们在做项目迁移时肯定也要将依赖的三方模块在要被迁移的电脑上安装，一个一个安装很麻烦

  > pip freeze > install.txt

  安装时

  > pip install -r install.txt

---



## 五、urllib 网络模块

> python内置了网络模块urllib，可以通过urllib模块发送网络请求

### 1. request的使用

```
# urllib 中有一个request方法
from urllib import request

# 定义请求地址
base_url = ''

# 发送get请求
response = request.urlopen(url=base_url)
```

* `urllib.request.urlretrieve(url, filename=None, reporthook=None, data=None)`

  > 将URL表示的网络对象复制到本地文件。

  | 参数       | 描述                                                         |
  | ---------- | ------------------------------------------------------------ |
  | url        | 外部或者本地url                                              |
  | filename   | 指定了保存到本地的路径（如果未指定该参数，urllib会生成一个临时文件来保存数据） |
  | reporthook | 是一个回调函数，当连接上服务器、以及相应的数据块传输完毕的时候会触发该回调。我们可以利用这个回调函数来显示当前的下载进度。 |
  | data       | 指post到服务器的数据。该方法返回一个包含两个元素的元组(filename, headers)，filename表示保存到本地的路径，header表示服务器的响应头。 |


### 2. 构造请求头Request

> 我们可以利用urlopen()方法可以实现最基本请求的发起，
>
> 但这几个简单的参数并不足以构建一个完整的请求，
>
> 如果请求中需要加入headers（请求头）等信息，
>
> 我们就可以利用更强大的Request类来构建一个请求。

```python
# 有些网站会有些反爬手段验证浏览器, 所以我们要伪装我们的爬虫程序让他看起来更像是浏览器
from urllib import request

# 定义请求地址
base_url = ''
# 定义请求头
headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.84 Safari/537.36'

}
# 构造请求头
req = request.Request(url=base_url,headers=headers)

# 发送get请求
response = request.urlopen(req)

# 处理响应
html=response.read().decode('utf-8')

with open('./xici.html','w',encoding='utf-8') as f:
    f.write(html)
```

```python
import urllib.request
import urllib.parse

url = 'http://httpbin.org/post'
headers = {'User-Agent':'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36'}
headers['Host'] = 'httpbin.org'
dict = {'name':'Germey'}

data = urllib.parse.urlencode(dict).encode('utf-8')
#data参数如果要传必须传bytes（字节流）类型的，如果是一个字典，先用urllib.parse.urlencode()编码。
request = urllib.request.Request(url = url,data = data,headers = headers,method = 'POST')

response = urllib.request.urlopen(request)
html = response.read().decode('utf-8')

print(html)
```



### 3. url地址中文转码

> urllib 中除了提供了request 还提供了parse用于处理url请求地址 中文要进行转码

#### parse

* parse.urlencode

```python
from urllib import request,parse
# 定义请求地址
# http://www.baidu.com/s?wd=美女
# http://www.baidu.com/s?wd=%e7%be%8e%e5%a5%b3
base_url =  'http://www.baidu.com/s?'   

# 定义参数
data = {
    wd: '美女'
}

# 解析url
msg = parse.urlencode(data)
# 拼接url
url = base_url+msg

# 发送请求
response = request.urlopen(url=url)
```

* urllib.parse.urljoin() 拼接url地址

split

replace

#### strip()

> Python strip() 方法用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。

> **注意：**该方法只能删除开头或是结尾的字符，不能删除中间部分的字符。

* 格式 :

  ```
  str.strip([chars]);
  ```

* 参数:

  chars -- 移除字符串头尾指定的字符序列。

* 返回值:

  返回移除字符串头尾指定的字符生成的新字符串。

  ```
  str = "00000003210Runoob01230000000"; 
  print str.strip( '0' );  # 去除首尾字符 0
   
   
  str2 = "   Runoob      ";   # 去除首尾空格
  print str2.strip();
  
  以上实例输出结果如下：
  3210Runoob0123
  Runoob
  ```
  



#### format()

> format()基本语法是通过 {} 和 : 来代替以前的 % 。

* format 函数可以接受不限个参数，位置可以不按顺序。

  ```
  >>>"{} {}".format("hello", "world")    # 不设置指定位置，按默认顺序
  'hello world'
   
  >>> "{0} {1}".format("hello", "world")  # 设置指定位置
  'hello world'
   
  >>> "{1} {0} {1}".format("hello", "world")  # 设置指定位置
  'world hello world'
  ```

* 也可以设置参数：

  ```
  print("网站名：{name}, 地址 {url}".format(name="菜鸟教程", url="www.runoob.com"))
   
  # 通过字典设置参数
  site = {"name": "菜鸟教程", "url": "www.runoob.com"}
  print("网站名：{name}, 地址 {url}".format(**site))
   
  # 通过列表索引设置参数
  my_list = ['菜鸟教程', 'www.runoob.com']
  print("网站名：{0[0]}, 地址 {0[1]}".format(my_list))  # "0" 是必须的
  
  输出结果为：
  网站名：菜鸟教程, 地址 www.runoob.com
  网站名：菜鸟教程, 地址 www.runoob.com
  网站名：菜鸟教程, 地址 www.runoob.com
  ```

* > 也可以向 str.format() 传入对象
  >
  > 数字格式化

[Python format 格式化函数]: http://www.runoob.com/python/att-string-format.html




### 4. ssl认证问题

> https是基于ssl进行的加密认证，所以在发送https请求时需要认证证书，我们可以设置跳过认证

```python
import ssl
ssl._create_default_https_context = ssl._create_unverified_context # 默认不需要校验网站证书
```



### 5. 代理的使用

> 代理的使用可以在一些方面提升数据采集的速度，和防止ip被封，也算是一种反反爬的手段

* **非认证代理**

  ```
  # 定义代理 
  proxy={
     'http': 'http://ip:prot',
     'https': 'https://ip:端口号'
  }
  # 创建代理对象
  proxy_handler = request.ProxyHandler(proxy)
  # 自定义请求方法
  opener = requests.build_opener(proxy_handler)
  
  # 发送请求
  response = opener.open(url)
  ```

* **认证代理**

  ```
  # 定义代理
  proxy = {
      'http':'http://user：password@ip:port',
      'https':'https://user：password@ip:port',
  }
  # 创建代理对象
  proxy_handler = request.ProxyHandler(proxy)
  # 自定义请求对象
  opener = request.build_opener(proxy_handler)
  # 发送请求
  response = opener.open(url)
  ```

---



## 六、requests模块

> requests 是一个第三方的网络模块，对urllib进行了封装，简化了urllib的操作，使用起来更方便

* **安装**`pip install requests`

* **发送get请求**

  格式:` requests.get(url,headers=headers)`

*  **发送get请求**  

  格式:` requests.get(url,headers=headers)`

* **发送post请求**  

  格式: `requests.post(url,headers=headers,data=data)  `

  ```
  data={
  
     }
  requests.post(url,headers=headers,data=data)
  ```

* **以encoding解析返回内容**

  格式:` r.text` 

* **添加代理**  

  格式: requests.get(url,proxies=proxy)  

  ```
  proxy={
        'http': 'http://ip:port',
        'https': 'https://ip:port'
    }
    proxy={
        'http': 'http://user:password@ip:port',
        'https': 'https://user:password@ip:port'
    }
    requests.get(url,proxies=proxy)
  ```

* **构建会话信息**

  格式: session = requests.session()  

  ```
   # 实例化会话
   session = requests.session()
  
   # 发送请求
   session.get()
   session.post()
  ```

---



## 七、re模块--正则

> 又称规则表达式，通常被用来检索，替换符合某个规则的文本字符串

* 常用方法：

  ```
  compile: 将正则表达式模式编译成一个正则表达式对象
  search：从字符串开始检索到结尾，返回第一次匹配到的内容
  match : 默认在规则前边加上^
  findall : 从头到尾检索，匹配所有符合规则的字符串，返回列表
  finditer ：返回迭代器
  ```



### 1. 正则表达式修饰符 - 可选标志

> 正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志：

| 修饰符 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| re.I   | 使匹配对大小写不敏感, 忽略大小写                             |
| re.L   | 做本地化识别（locale-aware）匹配                             |
| re.M   | 多行匹配，影响 ^ 和 $                                        |
| re.S   | 使 . 匹配包括换行在内的所有字符                              |
| re.U   | 根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.      |
| re.X   | 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。 |

### 2. 正则表达式模式

| 模式         | 描述                                                         |
| ------------ | ------------------------------------------------------------ |
| ^            | 匹配字符串的开头                                             |
| $            | 匹配字符串的末尾。                                           |
| .            | 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 |
| [...]        | 用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k'          |
| [^...]       | 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。             |
| re*          | 匹配0个或多个的表达式。                                      |
| re+          | 匹配1个或多个的表达式。                                      |
| re?          | 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式         |
| re{ n}       | 匹配n个前面表达式。例如，"o{2}"不能匹配"Bob"中的"o"，但是能匹配"food"中的两个o。 |
| re{ n,}      | 精确匹配n个前面表达式。例如，"o{2,}"不能匹配"Bob"中的"o"，但能匹配"foooood"中的所有o。"o{1,}"等价于"o+"。"o{0,}"则等价于"o*"。 |
| re{ n, m}    | 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式         |
| a\| b        | 匹配a或b                                                     |
| (re)         | 匹配括号内的表达式，也表示一个组                             |
| (?imx)       | 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。 |
| (?-imx)      | 正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。     |
| (?: re)      | 类似 (...), 但是不表示一个组                                 |
| (?imx: re)   | 在括号中使用i, m, 或 x 可选标志                              |
| (?-imx: re)  | 在括号中不使用i, m, 或 x 可选标志                            |
| (?#...)      | 注释.                                                        |
| (?= re)      | 前向肯定界定符。如果所含正则表达式，以 ... 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。 |
| (?! re)      | 前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功。 |
| (?> re)      | 匹配的独立模式，省去回溯。                                   |
| \w           | 匹配数字字母下划线                                           |
| \W           | 匹配非数字字母下划线                                         |
| \s           | 匹配任意空白字符，等价于 [\t\n\r\f]。                        |
| \S           | 匹配任意非空字符                                             |
| \d           | 匹配任意数字，等价于 [0-9]。                                 |
| \D           | 匹配任意非数字                                               |
| \A           | 匹配字符串开始                                               |
| \Z           | 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。 |
| \z           | 匹配字符串结束                                               |
| \G           | 匹配最后匹配完成的位置。                                     |
| \b           | 匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。 |
| \B           | 匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。 |
| \n, \t, 等。 | 匹配一个换行符。匹配一个制表符, 等                           |
| \1...\9      | 匹配第n个分组的内容。                                        |
| \10          | 匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。 |



### 3. re函数、方法使用

> 若匹配规则里有1个括号------返回的是括号所匹配到的结果，
>
> 若匹配规则里有多个括号------返回多个括号分别匹配到的结果，
>
> 若匹配规则里没有括号------就返回整条语句所匹配到的结果。

* **compile 函数**

  > compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。

  格式：`re.compile(pattern[, flags])`

  | 参数       | 描述                                     |
  | ---------- | ---------------------------------------- |
  | pattern    | 一个字符串形式的正则表达式               |
  | flags 可选 | 表示匹配模式，比如忽略大小写，多行模式等 |

  ```
  >>>import re
  >>> pattern = re.compile(r'\d+')                    # 用于匹配至少一个数字
  >>> m = pattern.match('one12twothree34four')        # 查找头部，没有匹配
  >>> print m
  None
  >>> m = pattern.match('one12twothree34four', 2, 10) # 从'e'的位置开始匹配，没有匹配
  >>> print m
  None
  >>> m = pattern.match('one12twothree34four', 3, 10) # 从'1'的位置开始匹配，正好匹配
  >>> print m                                         # 返回一个 Match 对象
  <_sre.SRE_Match object at 0x10a42aac0>
  >>> m.group(0)   # 可省略 0
  '12'
  >>> m.start(0)   # 可省略 0
  3
  >>> m.end(0)     # 可省略 0
  5
  >>> m.span(0)    # 可省略 0
  (3, 5)
  ```

  在上面，当匹配成功时返回一个 Match 对象，其中：

  - `group([group1, …])` 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 `group()`或 `group(0)`；
  - `start([group])` 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0；
  - `end([group])` 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0；
  - `span([group])` 方法返回 `(start(group), end(group))`。

* **re.search方法**

  > re.search 扫描整个字符串并返回第一个成功的匹配。

  格式: `re.search(pattern, string, flags=0)`

  | 参数    | 描述                                                         |
  | ------- | ------------------------------------------------------------ |
  | pattern | 匹配的正则表达式                                             |
  | string  | 要匹配的字符串。                                             |
  | flags   | 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：正则表达式修饰符 - 可选标志 |



* **re.match函数**

  > 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。

  格式：`re.match(pattern, string, flags=0)`

  | 参数    | 描述                                                         |
  | ------- | ------------------------------------------------------------ |
  | pattern | 匹配的正则表达式                                             |
  | string  | 要匹配的字符串。                                             |
  | flags   | 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：正则表达式修饰符 - 可选标志 |

> re.match与re.search的区别
>
> re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；
>
> re.search匹配整个字符串，直到找到一个匹配。



* **group(num)** 

  >匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。

  ```
  import re
  line = "Cats are smarter than dogs";
   
  searchObj = re.search( r'(.*) are (.*?) .*', line, re.M|re.I)
   
  if searchObj:
     print ("searchObj.group() : ", searchObj.group())
     print ("searchObj.group(1) : ", searchObj.group(1))
     print ("searchObj.group(2) : ", searchObj.group(2))
  else:
     print ("Nothing found!!")
     
  以上实例执行结果如下：   
  searchObj.group() :  Cats are smarter than dogs
  searchObj.group(1) :  Cats
  searchObj.group(2) :  smarter
  ```


* **findall**

  > 在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。
  >
  > **注意：** match 和 search 是匹配一次 findall 匹配所有。

  格式: `findall(string[, pos[, endpos]])`

  | 参数   | 描述                                                 |
  | ------ | ---------------------------------------------------- |
  | string | 待匹配的字符串。                                     |
  | pos    | 可选参数，指定字符串的起始位置，默认为 0。           |
  | endpos | 可选参数，指定字符串的结束位置，默认为字符串的长度。 |

  ```
  ['123', '456']import re
   
  pattern = re.compile(r'\d+')   # 查找数字
  result1 = pattern.findall('runoob 123 google 456')
  result2 = pattern.findall('run88oob123google456', 0, 10)
   
  print(result1)
  print(result2)
  
  输出结果：
  ['123', '456']
  ['88', '12']
  ```

* **re.finditer**

  > 和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。

  格式: `finditer(pattern, string, flags=0)`

  | 参数    | 描述                                                         |
  | ------- | ------------------------------------------------------------ |
  | pattern | 匹配的正则表达式                                             |
  | string  | 要匹配的字符串。                                             |
  | flags   | 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：正则表达式修饰符 - 可选标志 |

  ```
  import re
   
  it = re.finditer(r"\d+","12a32bc43jf3") 
  for match in it: 
      print (match.group() )
      
  输出结果：
  12 
  32 
  43 
  3
  ```



* **re.split**

  > split 方法按照能够匹配的子串将字符串分割后返回列表

  格式: `re.split(pattern, string[, maxsplit=0, flags=0])`

  | 参数     | 描述                                                         |
  | -------- | ------------------------------------------------------------ |
  | pattern  | 匹配的正则表达式                                             |
  | string   | 要匹配的字符串。                                             |
  | maxsplit | 分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数。        |
  | flags    | 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：正则表达式修饰符 - 可选标志 |

---



## 八、json模块--数据处理

>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，它使得人们很容易的进行阅读和编写。同时也方便了机器进行解析和生成。适用于进行数据交互的场景，比如网站前台与后台之间的数据交互。

> json简单说就是javascript中的对象和数组，所以这两种结构就是对象和数组两种结构，通过这两种结构可以表示各种复杂的结构

* **json.dumps()**

  `json.dumps()` 用于将 Python 对象编码成 JSON 字符串。

* **json.loads()**

  `json.loads()` 用于解码 JSON 数据。该函数返回 Python 字段的数据类型。

```python
import requests
import json
response = requests.get('http://httpbin.org/get')
<br>res1 = json.loads(response.text) #太麻烦
res2=response.json() #直接获取json数据
print(res1 == res2) #True
```

---



## 九、jsonpath

### 1. 作用

类似于XPath在xml文档中的定位，JsonPath表达式通常是用来路径检索或设置Json的。

### 2. 操作符

| 符号                    | 描述                                                         |
| ----------------------- | ------------------------------------------------------------ |
| $                       | 查询的根节点对象，用于表示一个json数据，可以是数组或对象     |
| @                       | 过滤器断言（filter predicate）处理的当前节点对象，类似于java中的this字段 |
| *                       | 通配符，可以表示一个名字或数字                               |
| ..                      | 可以理解为递归搜索，Deep scan. Available anywhere a name is required. |
| .<name>                 | 表示一个子节点                                               |
| [‘<name>’ (, ‘<name>’)] | 表示一个或多个子节点                                         |
| [<number> (, <number>)] | 表示一个或多个数组下标                                       |
| [start:end]             | 数组片段，区间为[start,end),不包含end                        |
| [?(<expression>)]       | 过滤器表达式，表达式结果必须是boolean                        |

### 3. 函数

> 可以在JsonPath表达式执行后进行调用，其输入值为表达式的结果。

| 名称     | 描述                     | 输出    |
| -------- | ------------------------ | ------- |
| min()    | 获取数值类型数组的最小值 | Double  |
| max()    | 获取数值类型数组的最大值 | Double  |
| avg()    | 获取数值类型数组的平均值 | Double  |
| stddev() | 获取数值类型数组的标准差 | Double  |
| length() | 获取数值类型数组的长度   | Integer |

### 4. 过滤器

> 过滤器是用于过滤数组的逻辑表达式，一个通常的表达式形如：[?(@.age > 18)]，可以通过逻辑表达式&&或||组合多个过滤器表达式，例如[?(@.price < 10 && @.category == ‘fiction’)]，字符串必须用单引号或双引号包围，例如[?(@.color == ‘blue’)] or [?(@.color == “blue”)]。

| 操作符 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| ==     | 等于符号，但数字1不等于字符1(note that 1 is not equal to ‘1’) |
| !=     | 不等于符号                                                   |
| <      | 小于符号                                                     |
| <=     | 小于等于符号                                                 |
| >      | 大于符号                                                     |
| >=     | 大于等于符号                                                 |
| =~     | 判断是否符合正则表达式，例如[?(@.name =~ /foo.*?/i)]         |
| in     | 所属符号，例如[?(@.size in [‘S’, ‘M’])]                      |
| nin    | 排除符号                                                     |
| size   | size of left (array or string) should match right            |
| empty  | 判空符号                                                     |

### 5. 例子

> 让我们通过更多示例来练习JSONPath表达式。我们从一个表示书店（原始[XML文件](http://coli.lili.uni-bielefeld.de/~andreas/Seminare/sommer02/books.xml)）的XML示例之后构建的简单JSON结构开始。

```
{ “store”：{
     “book”：[
      { “category”：“reference”，
         “author”：“Nigel Rees”，
         “title”：“世纪的谚语”，
         “价格”：8.95
      }，
      { “类别”：“小说”，
         “作者”：“伊夫林沃”，
         “标题”：“荣誉之剑”，
         “价格”：12.99
      }，
      { “类别”：“小说”，
         “作者”：“Herman Melville”，
         “title”：“Moby Dick”，
         “isbn”：“0-553-21311-3”，
         “price”：8.99
      }，
      { “类别”：“小说”，
         “作者”：“JRR托尔金”，
         “标题”：“指环王”，
         “isbn”：“0-395-19395-8”，
         “价格”：22.99
      }
    ]
    “自行车”：{
       “颜色”：“红色”，
       “价格”：19.95
    }
  }
}
```

| **XPath的**          | **JSONPath**                       | **结果**                                         |
| -------------------- | ---------------------------------- | ------------------------------------------------ |
| /store/book/author   | $.store.book[*].author             | 商店里所有书籍的作者                             |
| //author             | $..author                          | 所有作者                                         |
| /store/*             | $.store.*                          | 商店里的所有东西，都是一些书和一辆红色的自行车。 |
| /store//price        | $.store..price                     | 商店里一切的价格。                               |
| //book[3             | $..book[2]                         | 第三本书                                         |
| //book[last()]       | $..book[(@.length-1)] $..book[-1:] | 最后一本书。                                     |
| //book[position()<3] | $..book[0,1] $..book[:2]           | 前两本书                                         |
| //book[isbn]         | $..book[?(@.isbn)]                 | 使用isbn number过滤所有书籍                      |
| //book[price<10]     | `$..book[?(@.price<10)]`           | 过滤所有便宜10以上的书籍                         |
| //*                  | $..*                               | XML文档中的所有元素。JSON结构的所有成员。        |

---



## 十、xpath

### 1. 简介

> XPath 是一门在 XML 文档中查找信息的语言。XPath 可用来在 XML 文档中对元素和属性进行遍历。XPath 是 W3C XSLT 标准的主要元素，并且 XQuery 和 XPointer 都构建于 XPath 表达之上。

### 2. 使用

* **安装**

  ```
  pip install lxml
  ```

* **导入**

  ```
  from lxml import etree
  ```

* **基本使用**

  ```
  from lxml import etree
   
  wb_data = """
          <div>
              <ul>
                   <li class="item-0"><a href="link1.html">first item</a></li>
                   <li class="item-1"><a href="link2.html">second item</a></li>
                   <li class="item-inactive"><a href="link3.html">third item</a></li>
                   <li class="item-1"><a href="link4.html">fourth item</a></li>
                   <li class="item-0"><a href="link5.html">fifth item</a>
               </ul>
           </div>
          """
  html = etree.HTML(wb_data)
  print(html)
  result = etree.tostring(html)
  print(result.decode("utf-8"))
  ```

### 3. Xpath语法

```
<?xml version="1.0" encoding="ISO-8859-1"?>

<bookstore>

<book>
  <title lang="eng">Harry Potter</title>
  <price>29.99</price>
</book>

<book>
  <title lang="eng">Learning XML</title>
  <price>39.95</price>
</book>

</bookstore>
```

#### 3.1 选取节点

| 表达式   | 描述                                                       |
| -------- | ---------------------------------------------------------- |
| nodename | 选取此节点的所有子节点。                                   |
| /        | 从根节点选取。                                             |
| //       | 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。 |
| .        | 选取当前节点。                                             |
| ..       | 选取当前节点的父节点。                                     |
| @        | 选取属性。                                                 |

实例

> 在下面的表格中，我们已列出了一些路径表达式以及表达式的结果：

| 路径表达式      | 结果                                                         |
| --------------- | ------------------------------------------------------------ |
| bookstore       | 选取 bookstore 元素的所有子节点。                            |
| /bookstore      | 选取根元素 bookstore。注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！ |
| bookstore/book  | 选取属于 bookstore 的子元素的所有 book 元素。                |
| //book          | 选取所有 book 子元素，而不管它们在文档中的位置。             |
| bookstore//book | 选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。 |
| //@lang         | 选取名为 lang 的所有属性。                                   |



#### 3.2 谓语（Predicates）

实例

> 在下面的表格中，我们列出了带有谓语的一些路径表达式，以及表达式的结果：

| 路径表达式                         | 结果                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| /bookstore/book[1]                 | 选取属于 bookstore 子元素的第一个 book 元素。                |
| /bookstore/book[last()]            | 选取属于 bookstore 子元素的最后一个 book 元素。              |
| /bookstore/book[last()-1]          | 选取属于 bookstore 子元素的倒数第二个 book 元素。            |
| /bookstore/book[position()<3]      | 选取最前面的两个属于 bookstore 元素的子元素的 book 元素。    |
| //title[@lang]                     | 选取所有拥有名为 lang 的属性的 title 元素。                  |
| //title[@lang='eng']               | 选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。   |
| /bookstore/book[price>35.00]       | 选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。 |
| /bookstore/book[price>35.00]/title | 选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。 |



#### 3.3 选取未知节点

> XPath 通配符可用来选取未知的 XML 元素。

| 通配符 | 描述                 |
| ------ | -------------------- |
| *      | 匹配任何元素节点。   |
| @*     | 匹配任何属性节点。   |
| node() | 匹配任何类型的节点。 |

实例

> 在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：

| 路径表达式   | 结果                              |
| ------------ | --------------------------------- |
| /bookstore/* | 选取 bookstore 元素的所有子元素。 |
| //*          | 选取文档中的所有元素。            |
| //title[@*]  | 选取所有带有属性的 title 元素。   |



#### 3.4 选取若干路径

> 通过在路径表达式中使用“|”运算符，您可以选取若干个路径。

实例

> 在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：

| 路径表达式                       | 结果                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| //book/title \| //book/price     | 选取 book 元素的所有 title 和 price 元素。                   |
| //title \| //price               | 选取文档中的所有 title 和 price 元素。                       |
| /bookstore/book/title \| //price | 选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。 |

---



## 十一、进程线程协程

### 1. 概念

#### 1.1 线程

> **线程是一个基本的 CPU 执行单元。**它必须依托于进程存活。一个线程是一个 CPU 执行时所需要的一串指令。

#### 1.2 进程

> 进程是指一个程序在给定数据集合上的一次执行过程，**是系统进行资源分配和运行调用的独立单位。**可以简单地理解为操作系统中正在执行的程序。也就说，每个应用程序都有一个自己的进程。
>
> 每一个进程启动时都会最先产生一个线程，即主线程。然后主线程会再创建其他的子线程。

#### 1.3 两者的区别

- 线程必须在某个进程中执行。
- 一个进程可包含多个线程，其中有且只有一个主线程。
- 多线程共享同个地址空间、打开的文件以及其他资源。
- 多进程共享物理内存、磁盘、打印机以及其他资源。



### 2. Python 多进程

#### 2.1 创建多进程Process 

> Python 要进行多进程操作，需要用到`muiltprocessing`库中的`Process`类

- 方法：使用`Process`

  ```
  from multiprocessing import Process  
  
  def show(name):
      print("Process name is " + name)
  
  if __name__ == "__main__": 
      proc = Process(target=show, args=('subprocess',))  
      proc.start()  
      proc.join()
  ```

#### 2.2 多进程通信Queue

> 进程之间不共享数据的。如果进程之间需要进行通信，则要用到`Queue模块`或者`Pipi模块`来实现

* Queue

  >Queue 是多进程安全的队列，可以实现多进程之间的数据传递。它主要有两个函数,`put`和`get`。
  >
  >put() 用以插入数据到队列中，put 还有两个可选参数：blocked 和 timeout。如果 blocked 为 True（默认值），并且 timeout 为正值，该方法会阻塞 timeout 指定的时间，直到该队列有剩余的空间。如果超时，会抛出 Queue.Full 异常。如果 blocked 为 False，但该 Queue 已满，会立即抛出 Queue.Full 异常。
  >
  >get()可以从队列读取并且删除一个元素。同样，get 有两个可选参数：blocked 和 timeout。如果 blocked 为 True（默认值），并且 timeout 为正值，那么在等待时间内没有取到任何元素，会抛出 Queue.Empty 异常。如果blocked 为 False，有两种情况存在，如果 Queue 有一个值可用，则立即返回该值，否则，如果队列为空，则立即抛出 Queue.Empty 异常。

  ```
  from multiprocessing import Process, Queue
   
  def put(queue):
      queue.put('Queue 用法')
   
  if __name__ == '__main__':
      queue = Queue()
      pro = Process(target=put, args=(queue,))
      pro.start()
      print(queue.get())   
      pro.join()
  ```

#### 2.3 进程池Pool

> 创建多个进程，我们可以使用`Pool`模块来搞定。

Pool 常用的方法如下：

| 方法          | 含义                                                         |
| ------------- | ------------------------------------------------------------ |
| apply()       | 同步执行（串行）                                             |
| apply_async() | 异步执行（并行）                                             |
| terminate()   | 立刻关闭进程池                                               |
| join()        | 主进程等待所有子进程执行完毕。必须在close或terminate()之后使用 |
| close()       | 等待所有进程结束后，才关闭进程池                             |

```
from multiprocessing import Pool
def show(num):
    print('num : ' + str(num))

if __name__=="__main__":
    pool = Pool(processes = 3)
    for i in range(6):
        # 维持执行的进程总数为processes，当一个进程执行完毕后会添加新的进程进去
        pool.apply_async(show, args=(i, ))       
    print('======  apply_async  ======')
    pool.close()
    #调用join之前，先调用close函数，否则会出错。执行完close后不会有新的进程加入到pool,join函数等待所有子进程结束
    pool.join()
```



### 3 Python 多线程

#### 3.1 创建多线程threading

> Python提供两个模块进行多线程的操作，分别是`thread`和`threading`

- 方法1：直接使用`threading.Thread()`

  ```
  import threading
  
  # 这个函数名可随便定义
  def run(n):
      print("current task：", n)
  
  if __name__ == "__main__":
      t1 = threading.Thread(target=run, args=("thread 1",))
      t2 = threading.Thread(target=run, args=("thread 2",))
      t1.start()
      t2.start()
  ```

#### 3.2 线程合并

> `Join`函数执行顺序是逐个执行每个线程，执行完毕后继续往下执行。主线程结束后，子线程还在运行，`join`函数使得主线程等到子线程结束时才退出。

```
import threading

def count(n):
    while n > 0:
        n -= 1

if __name__ == "__main__":
    t1 = threading.Thread(target=count, args=(100000,))
    t2 = threading.Thread(target=count, args=(100000,))
    t1.start()
    t2.start()
    # 将 t1 和 t2 加入到主线程中
    t1.join()
    t2.join()
```



### 4. 协程

>子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。
>
>协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。

#### 4.1 主要的优点

- 执行效率极高，因为子程序切换（函数）不是线程切换，由程序自身控制，没有切换线程的开销。所以与多线程相比，线程的数量越多，协程性能的优势越明显。
- 不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在控制共享资源时也不需要加锁，因此执行效率高很多。

#### 4.2 gevent使用

```
# 导入gevent包
import gevent
import time
# 猴子 monkey, 猴子补丁
from gevent import monkey
monkey.patch_all()
import requests

def visit_web_page(url):
    print('正在下载url: ', url)
    response = requests.get(url)
    print('url : code=' + str(response.status_code) + 'URL:' + url)

if __name__ == '__main__':

    # 生成一个类
    g1 = gevent.spawn(visit_web_page, 'http://www.baidu.com')
    g2 = gevent.spawn(visit_web_page, 'https://www.python.org')
    g3 = gevent.spawn(visit_web_page, 'http://www.sina.com')
    # 等待这些协程结束
    gevent.joinall([g1, g2, g3])
```



### 5. 进程、线程和协程的区别

* 进程：

  > 进程之间不共享任何状态，进程的调度由操作系统完成，每个进程都有自己独立的内存空间，进程间通讯主要是通过信号传递的方式来实现的，实现方式有多种，信号量、管道、事件等，任何一种方式的通讯效率都需要过内核，导致通讯效率比较低。由于是独立的内存空间，上下文切换的时候需要保存先调用栈的信息、cpu各寄存器的信息、虚拟内存、以及打开的相关句柄等信息，所以导致上下文进程间切换开销很大，通讯麻烦。 

* 线程：

  > 线程之间共享变量，解决了通讯麻烦的问题，但是对于变量的访问需要锁，线程的调度主要也是有操作系统完成，一个进程可以拥有多个线程，但是其中每个线程会共享父进程像操作系统申请资源，这个包括虚拟内存、文件等，由于是共享资源，所以创建线程所需要的系统资源占用比进程小很多，相应的可创建的线程数量也变得相对多很多。线程时间的通讯除了可以使用进程之间通讯的方式以外还可以通过共享内存的方式进行通信，所以这个速度比通过内核要快很多。另外在调度方面也是由于内存是共享的，所以上下文切换的时候需要保存的东西就像对少一些，这样一来上下文的切换也变得高效。

* 协程：

  > 协程的调度完全由用户控制，一个线程可以有多个协程，用户创建了几个线程，然后每个线程都是循环按照指定的任务清单顺序完成不同的任务，当任务被堵塞的时候执行下一个任务，当恢复的时候再回来执行这个任务，任务之间的切换只需要保存每个任务的上下文内容，就像直接操作栈一样的，这样就完全没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快；另外协程还需要保证是非堵塞的且没有相互依赖，协程基本上不能同步通讯，多采用一步的消息通讯，效率比较高。

---



## 十二、Scrapy 框架





## 十三、selenium



# MySQL 数据库

[MySQL 教程](http://www.runoob.com/mysql/mysql-tutorial.html)

- **什么是数据库？**

  数据库（Database）是按照数据结构来组织、存储和管理数据的仓库，

  每个数据库都有一个或多个不同的API用于创建，访问，管理，搜索和复制所保存的数据。

  我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。

  所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理的大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。

- **RDBMS即关系数据库管理系统(Relational Database Management System)的特点：**

  1.数据以表格的形式出现

  2.每行为各种记录名称

  3.每列为记录名称所对应的数据域

  4.许多的行和列组成一张表单

  5.若干的表单组成database

- **数据库作用**

  1) 持久保存

  2) 方便查询并提取满足条件的数据, 数据访问速度快

  3) 处理并发访问

  4) 权限管理

- **常见数据库:**

  关系型数据库 MySQL ->库->表->数据 MySQL Oracle PostgreSQL SQL Server ....

  非关系型数据库 Redis ->数据 MongoDB ... 概念：

  数据： data

  数据库： DB

  数据库管理系统：DBMS

  数据库系统：DBS

## 一、MySQL基础操作

> 数据库管理系统中, 可以有很多库, 每个数据库中可以包括多张数据表



- **操作数据库的步骤**

  连接, 打开库, 操作, 关闭退出

- **SQL ( Structure query language ) 结构化查询语言**

  ```
  SQL语言分为4个部分：
      DDL（Data Definition Languages） :数据的定义
      DML（Data Manipulation Language）:数据的操作        
      DQL（Data Query Language）       :数据的查询操作
      DCL（Date Control Language）     :数据控制语句
  ```

- **SQL语句中的快捷键**

  > \G 格式化输出（文本式，竖立显示）
  >
  > \s 查看服务器端信息
  >
  > \c 结束命令输入操作
  >
  > \q 退出当前sql命令行模式
  >
  > \h 查看帮助

- **MySQL 语法特点**

  1. SQL 语句可以换行, 要以分号结尾
  2. 命令不区分大小写. 关键字和函数建议用大写
  3. 如果提示符为 '> 那么需要输入一个'回车
  4. 命令打错了换行后不能修改, 可以用 \c 取消

------



## 二、MySQL 数据类型

### 1. 数值类型

| 类型         | 大小                                     | 范围（有符号）                                               | 范围（无符号）                                               | 用途            |
| ------------ | ---------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | --------------- |
| TINYINT      | 1 字节                                   | (-128，127)                                                  | (0，255)                                                     | 小整数值        |
| SMALLINT     | 2 字节                                   | (-32 768，32 767)                                            | (0，65 535)                                                  | 大整数值        |
| MEDIUMINT    | 3 字节                                   | (-8 388 608，8 388 607)                                      | (0，16 777 215)                                              | 大整数值        |
| INT或INTEGER | 4 字节                                   | (-2 147 483 648，2 147 483 647)                              | (0，4 294 967 295)                                           | 大整数值        |
| BIGINT       | 8 字节                                   | (-9 233 372 036 854 775 808，9 223 372 036 854 775 807)      | (0，18 446 744 073 709 551 615)                              | 极大整数值      |
| FLOAT        | 4 字节                                   | (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) | 0，(1.175 494 351 E-38，3.402 823 466 E+38)                  | 单精度 浮点数值 |
| DOUBLE       | 8 字节                                   | (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 双精度 浮点数值 |
| DECIMAL      | 对DECIMAL(M,D) ，如果M>D，为M+2否则为D+2 | 依赖于M和D的值                                               | 依赖于M和D的值                                               | 小数值          |



### 2. 日期和时间类型

| 类型      | 大小(字节) | 范围                                    | 格式                | 用途                     |
| --------- | ---------- | --------------------------------------- | ------------------- | ------------------------ |
| DATA      | 3          | 1000-01-01/9999-12-31                   | YYYY-MM-DD          | 日期值                   |
| TIME      | 3          | '-838:59:59'/'838:59:59'                | HH:MM:SS            | 时间值或持续时间         |
| YEAR      | 1          | 1901/2155                               | YYYY                | 年份值                   |
| DATETIME  | 8          | 1000-01-01 00:00:00/9999-12-31 23:59:59 | YYYY-MM-DD HH:MM:SS | 混合日期和时间值         |
| TIMESTAMP | 4          | 1970-01-01 00:00:00/2037 年某时         | YYYYMMDD HHMMSS     | 混合日期和时间值，时间戳 |



### 3. 字符串类型

| 类型       | 大小                | 用途                            |
| ---------- | ------------------- | ------------------------------- |
| CHAR       | 0-255字节           | 定长字符串                      |
| VARCHAR    | 0-65535 字节        | 变长字符串                      |
| TINYBLOB   | 0-255字节           | 不超过 255 个字符的二进制字符串 |
| TINYTEXT   | 0-255字节           | 短文本字符串                    |
| BLOB       | 0-65 535字节        | 二进制形式的长文本数据          |
| TEXT       | 0-65 535字节        | 长文本数据                      |
| MEDIUMBLOB | 0-16 777 215字节    | 二进制形式的中等长度文本数据    |
| MEDIUMTEXT | 0-16 777 215字节    | 中等长度文本数据                |
| LONGBLOB   | 0-4 294 967 295字节 | 二进制形式的极大文本数据        |
| LONGTEXT   | 0-4 294 967 295字节 | 极大文本数据                    |

------



## 三、MySQL 运算符

算术运算符：**+ - * / %**

比较运算符：**= > < >= <= <> !=**

数据库特有的比较：**in，not in, is null,is not null,like, between and**

逻辑运算符：**and or not**

**like**: 支持特殊符号%和_ ; 其中 %表示任意数量的任意字符，_表示任意一位字符。

------



## 四、MySQL 库操作

1. 查看数据库 `show databases;`
2. 创建数据库 `create database 库名 default charset=utf8;`
3. 打开数据库 `use 库名;`
4. 查看当前库 `select database();`
5. 删除数据库 `drop database 库名;`

------



## 五、MySQL 表操作

### 1. 字段约束

**unsigned** : 无符号

**int(4)** : 显示宽度

**zerofill** :  零填充, 位数不够的时候用前导零填充

**not null** : 不能为空 在操作数据库时如果输入该字段的数据为NULL ，就会报错

**default** : 设置默认值

**auto_increment** : 定义列为自增的属性，一般用于主键，数值会自动加1。

**primary key** : 主键 不能为空 唯一性

**unique** : 唯一索引 可以为空 唯一性

**index** : 普通索引 可以为空 可以重复



### 2. 基本操作

查看当前库中所有表：`show tables;`

创建表 ：`create table 表名(字段1 类型 [字段约束],字段2 类型 [字段约束]...)default charset=utf8;`

查看表结构：`desc 表名;`

查看建表语句：`show create table 表名\G`

删除表：`drop table 表名;`

查看当前表中所有数据: `select * from 表名;`



### 3. 表数据操作

#### 3.1 增删改

> 数据的DML操作：添加数据，修改数据，删除数据

- 插入：格式  `insert into 表名[(字段列表)] values(值列表...);`

  ​            1. 标准添加: `insert into 表名(所有字段) values(对应的值);`

​		   2. 指定部分字段添加值: `insert into 表名 (部分字段) value (对应的值);`

​                   3. 不指定字段添加值: `insert into 表名 value(值1,值2,...);`

​		   4. 批量添加值: `insert into 表名 values(a值1,a值2,...),(b值1,b值2,...);`

- 删除：`delete from 表名 where 字段=某个值;`
- 修改：`update 表名 set 字段=某个值 where 条件;`

​		   `update 表名 set 字段1=值1,字段2=值2 where 条件;`

​		   `update 表名 set 字段=字段+值 where 条件;`

#### 3.2 查询

书写流程：where group by -->having order by limit

> 数据的DQL操作：数据查询

```mysql
 select [字段列表]  /*  from 表名

    [where 搜索条件]

    [group by 分组字段 [having 子条件]]

    [order by 排序 asc|desc]

    [limit 分页参数];
```

- **基础查询** : `select * from 表名;`

- **where条件查询**

  > - 你可以在 WHERE 子句中指定任何条件。
  > - 你可以使用 AND 或者 OR 指定一个或多个条件。
  > - WHERE 子句也可以运用于 SQL 的 DELETE 或者 UPDATE 命令。
  > - WHERE 子句**类似于程序语言中的 if 条件**，根据 MySQL 表中的字段值来读取指定的数据。

  ```mysql
  查询lamp138和lamp94期的女生信息
  mysql> select * from stu where classid in('lamp138','lamp94') and sex='w';
  ```

- **like子句**

  > - LIKE 通常与 % 一同使用，类似于一个元字符的搜索。
  > - 你可以使用 AND 或者 OR 指定一个或多个条件。
  > - 你可以在 DELETE 或 UPDATE 命令中使用 WHERE...LIKE 子句来指定条件。
  > - 可以使用regexp正则来代替 like

  ```
  查询name字段值是以zh开头的所有信息
  mysql> select * from stu where name like "zh%";
  ```

- **MySQL的统计函数(聚合函数):** `select max(),min(),sum()avg(),count(*) from 表名;`

- **GROUP BY 语句 分组 和 having** 

  > - GROUP BY 语句根据一个或多个列对结果集进行分组。
  > - 在分组的列上我们可以使用 COUNT, SUM, AVG,等函数。
  > - having 对分组后的数据进行删选 

  ```mysql
  MySQL> select classid,sex,count(*) from stu  group by classid,sex;
  ```

- **ORDER BY 排序 ------ asc 升序  / desc 降序**

  - 可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。
  - 可以设定多个字段来排序。
  - 可以使用 ASC 或 DESC 关键字来设置查询结果是按升序或降序排列。 默认为asc 按升序排列
  - 可以添加 WHERE...LIKE 子句来设置条件。

  ```mysql
  SELECT field1, field2,...fieldN table_name1, table_name2...
  ORDER BY field1, [field2...] [ASC [DESC]]
  ```

- **limit 关键字 查询部分数据**

  - limit m; 查询数据只显示前m条
  - limit m,n; 排除前m条，然后再查询出前n条



### 4. 表结构操作

> 格式: **alter table 表名 action(更改选项);**

```mysql
添加字段：alter table 表名 add 字段名 类型 [字段约束];

删除字段：alter table 表名 drop 字段名;

修改字段：change 可改字段名和类型; modify 可改字段类型, 不可改字段名
		alter table 表名 change 原字段名 修改后的字段名 类型 [字段约束];
        alter table 表名 modify 字段名 修改后的类型 [字段约束];

添加唯一性索引：alter table user add unique uni_name(name);

添加普通索引：alter table user add index index_email(email);

删除索引：alter table user drop index index_email;

修改表名：alter table 表名 rename as 新表名；

更改auto_increment初始值：alter table 表名称 auto_increment=数值；

更改表类型：alter table 表名 engine=‘innodb’;

		  alter table 表名 engine='myisam';
```

------



## 六、数据的导入和导出

### 1. 数据导出

```mysql
-- 导出整个数据库
mysqldump -u 用户名 -p 数据库名 >./导出的文件名.sql
Enter password:
-- 导出一个表
mysqldump -u 用户名 -p 数据库名 表名 >./导出的文件名.sql
Enter password:
```

### 2. 数据导入

```mysql
-- 将数据库导入
-- 需在本地数据库中创建相对应同名的数据库
mysql -u 用户名 -p 数据库名<./文件名.sql
Enter password:

```

------



## 七、授权、改密

### 1. 授权

格式：grant 允许操作 on 库名.表名 to 账号@来源 identified by '密码';

```mysql
实例：创建zhangsan账号，密码123，授权lamp61库下所有表的增/删/改/查数据,来源地不限
 mysql> grant select,insert,update,delete on lamp61.* to zhangsan@'%' identified   by '123';
 mysql> grant all on *.* to zhangsan@'%' identified by '123';
 Query OK, 0 rows affected (0.00 sec)

 添加用户, 并授予在lamp189的数据库中可以对user表进行 查询和添加数据操作
 GRANT select,insert ON lamp189.user TO 'xxoo'@'%' IDENTIFIED BY 'abcd'

 删除用户
 drop user 'xxoo'@'%'
```

### 2. 改密

```mysql
1.找到mysql配置文件 C:\ProgramData\MySQL\MySQL Server 5.7\my.ini
2.在[mysqld] 下面添加 skip-grant-tables 保存
3.重启mysql服务
4.打开命令行 mysql -uroot -p  不用输入密码
5.use mysql 切换到权限库
6.执行修改密码 Update user set authentication_string=password('1234567') where user='root';
7:执行刷新权限 flush privileges;
修改成功后：要把配置文件改回来 然后在重启服务
使用新密码链接数据库
```

------



## 八、Python 连接数据库

[Python3 MySQL 数据库连接](http://www.runoob.com/python3/python3-mysql.html)

### 1. PyMySQL安装

```
pip install pymysql
```

### 2. 连接数据库

> 通过如下代码测试数据库连接

```python
 import pymysql
 
 # 打开数据库连接
 db = pymysql.connect("localhost","root","123456","mydb" )

 # 使用 cursor() 方法创建一个游标对象 cursor
 cursor = db.cursor()

 # 使用 execute()  方法执行 SQL 查询 
 cursor.execute("SELECT VERSION()")

 # 使用 fetchone() 方法获取单条数据.
 data = cursor.fetchone()

 print ("Database version : %s " % data)

 # 关闭数据库连接
 db.close()
```

### 3. 执行数据添加

```python
import pymysql

# 打开数据库连接
db = pymysql.connect("localhost","root","123456","mydemo" )

# 使用 cursor() 方法创建一个游标对象 cursor
cursor = db.cursor()

# SQL 插入语句
sql = "INSERT INTO stu(name,sex,age,classid) values('%s','%c','%d','%s')" % ('uu142','m',22,'lamp180') 

try:
   # 执行sql语句
   cursor.execute(sql)
   # 执行sql语句
   db.commit()
   print("ok: %d " % (cursor.rowcount))
except:
   # 发生错误时回滚
   db.rollback()

# 关闭数据库连接
db.close()
```

### 4. 执行删除操作

```python
 import pymysql

 # 打开数据库连接
 db = pymysql.connect("localhost","root","","mydemo" )

 # 使用 cursor() 方法创建一个游标对象 cursor
 cursor = db.cursor()

 # SQL 删除语句
 sql = "delete from stu where id = '%d'" % (13)
 try:
    # 执行SQL语句
    cursor.execute(sql)
    # 提交修改
    db.commit()
 except:
    # 发生错误时回滚
    db.rollback()

 # 关闭数据库连接
 db.close()
```

### 5. 执行数据修改/更新

```python
import pymysql

# 打开数据库连接
db = pymysql.connect("localhost","testuser","test123","TESTDB" )

# 使用cursor()方法获取操作游标 
cursor = db.cursor()

# SQL 更新语句
sql = "UPDATE EMPLOYEE SET AGE = AGE + 1
                          WHERE SEX = '%c'" % ('M')
try:
   # 执行SQL语句
   cursor.execute(sql)
   # 提交到数据库执行
   db.commit()
except:
   # 发生错误时回滚
   db.rollback()

# 关闭数据库连接
db.close()
```

### 6. 执行数据查询

> Python查询Mysql使用 fetchone() 方法获取单条数据, 使用fetchall() 方法获取多条数据。
>
> fetchone(): 该方法获取下一个查询结果集。结果集是一个对象
>
> fetchall(): 接收全部的返回结果行.
>
> rowcount: 这是一个只读属性，并返回执行execute()方法后影响的行数。

```python
 import pymysql

 # 打开数据库连接
 db = pymysql.connect("localhost","root","","mydemo" )

 # 使用 cursor() 方法创建一个游标对象 cursor
 cursor = db.cursor()

 # SQL 查询语句
 sql = "select * from stu limit %d" % (3)
 #sql = "select * from stu"

 try:
    # 执行SQL语句
    cursor.execute(sql)
    # 获取所有记录列表
    results = cursor.fetchall()
    for row in results:
       id = row[0]
       name = row[1]
       sex = row[2]
       age = row[3]
       classid = row[4]
        # 打印结果
       print ("id=%d,name=%s,sex=%s,age=%d,classid=%s" % (id,name,sex,age,classid))
 except:
    print ("Error: unable to fetch data")

 # 关闭数据库连接
 db.close()
```

------



# Excel 操作

## 一、基础篇

### 1. Excel 2016快速入门

- **1.1 注册并登录Microsoft账户**

- **1.2 显示比例**

  视图 ----> 显示比例

- **1.3 隐藏网格**

  视图 ----> 去掉勾选网格线



### 2. 工作簿基本操作

- **2.1 保护工作表**

  保护:审阅---->保护工作表---->输入密码---->再次输入密码

  撤销:审阅---->撤销工作表保护---->输入密码

  保护工作表字段内容不能被修改

- **2.2 保护工作薄**

  保护:审阅---->保护工作簿---->输入密码

  撤销:审阅---->保护工作簿---->输入密码

  保护工作簿不能删除移动复制操作

- **2.3 加密工作簿**

  保护:文件---->信息---->保护工作薄---->用密码进行加密---->输入密码---->确认输入密码

  撤销:文件---->信息---->保护工作薄---->删除密码

- **2.4 新建窗口**

  视图---->新建窗口

- **2.5 并排查看两份数据**

  视图---->并排查看

- **2.6 拆分窗口**

  视图---->拆分,即可上下左右拖动混动条查看内容

  注意:恢复的话在点击一次拆分即可

- **2.7 设置自动保存时间间隔**

  文件---->选项---->保存---->保存自动回复信息时间间隔(填入时间)



### 3. 数据录入与编辑

- **3.1 插入行和列**

  开始---->插入---->插入工作表行

  开始---->插入---->插入工作表列

- **3.2 移动行和列**

  1. 拖住想要移动的单元格直接拖拽到想要移动的位置
  2. 剪贴 复制 粘贴

- **3.3 删除行和列**

  单击字母轴或者数字轴,选中右键删除即可

  多选的话,按下Ctrl或者Shift

- **3.4 调整行高和列高**

  单击字母轴或者数字轴,选中后鼠标放置边界线后开始拖拽宽高

- **3.5 显示与隐藏行与列**

  开始---->格式---->隐藏和取消隐藏---->(选中要操作的功能即可)

  或者右键选择隐藏和取消隐藏即可

  取消隐藏选中隐藏行/列的前后,点击取消隐藏

- **3.6 插入单元格或区域**

  (鼠标选定区域)---->开始---->插入---->插入单元格---->(选择需要操作的功能)

- **3.7 删除单元格或区域**

  (鼠标选定区域)---->开始---->删除---->删除单元格---->(选择需要操作的功能)

- **3.8 复制和移动单元格或区域**

  复制:(鼠标选定区域)---->开始---->复制---->(鼠标选定区域)---->粘贴

  移动:选中需要拖动的单元格或区域,鼠标放置边线变成十字箭头,即可拖到到指定位置即可

- **3.9 合并单元格**

  (鼠标选定区域)---->开始---->合并并居中(或者右侧的下拉菜单里面选择其他合并功能)

- **3.10 输入时期和时间**

  选中输入文本单元格,日期时间格式为 XX(年)-XX-(月)-XX(日)  XX(时):XX(分)

  例如: 2019-4-1 12:30

- **3.11 填充单元格或者区域**

  鼠标移至右下角,变成十字,下拉单元格,即可填充(在下拉完成后右下角会有下拉菜单,可以选择其他类型的填充)

- **3.12 查找与替换**

  查找:开始---->查找和选择---->查找(可选择查找下一个和查找全部)

  替换:开始---->查找和选择---->替换(可选择替换下一个和替换全部)

- **3.13 快速插入符号**

  选中单元格区域---->开始---->复制---->选中空白区域---->粘贴下拉菜单---->转置



### 4. 设置工作表

- **4.1 数字日期格式设置**

  开始---->数字(点击下拉菜单)---->选中想要设置的功能选项

- **4.2 设置上标与下标**

  开始---->数字---->常规(下拉框)---->选中文本

  更改文本格式以后

  选中要更改字体的上标文本,点击字体下拉框中单击上标,确定后即可

  下标的操作方法一样



### 5. 查阅与打印报表

- **5.1 在表中添加批注**

  选中需要批注的单元格

  审阅---->新建批注---->输入要批注的文本内容(批注过的数据右上角有红色三角标识,鼠标移入即可显示批注框,也可以在审阅里面点击上一条和下一条内容)

- **5.2 编辑批注内容**

  选中批注的单元格

  1.右键快捷键编辑批注

  2.审阅---->编辑批注

- **5.3 显示隐藏批注**

  选中批注的单元格

  审阅---->显示/隐藏批注|显示所有批注

- **5.4 移动批注或调整批注的大小**

  选中批注框

  移动鼠标光标变成四向时即可拖动批注位置

  移动鼠标光标变成双向即可调整批注宽高

- **5.5 设置批注的格式**

  选中批注框,移动鼠标光标变成四向时,

  右键<设置批注格式>,即可在里面选择对批注内容的设置

- **5.6 更改批注的默认名称**

  文件---->选项---->常规---->对Microsoft Office进行个性化设置---->用户名(设置新的名称)---->再次新建批注即可更改

- **5.7 复制批注**

  复制需要批注的单元格,单击<粘贴>按钮,在下拉选框中选择<选择性粘贴>

  单击<批注>确定即可

- **5.8 删除批注**

  选中需要删除带有批注的单元格

  审阅---->删除

- **5.9 对表进行拼写和语法检查**

  审阅---->校对(拼写检查)---->在里面进行功能选择

- **5.10 设置打印区域**

  选中需要打印的内容单元区域

  页面布局---->打印区域---->设置打印区域

  在文件菜单中选择打印即可

- **5.11 打印标题**

  页面布局---->页面设置---->工作表---->打印标题---->下面点击---->顶端标题行---->旁边的按钮，然后光标选中你需要每页都打印的表头部分，最后确定即可。

- **5.12 设置分页符**

  选中要分页的区域

  页面布局---->分隔符---->插入分页符

- **5.13 选定打印内容**

  打印批注的内容

  页面布局---->打印标题---->注释---->在下拉选框中选择<如同工作表中的显示>确定即可

- **5.14 设置纸张大小**

  视图---->页面布局

  页面布局---->纸张大小---->即可选择

  页面布局---->纸张大小---->(横向/纵向)

- **5.15 设置页边距**

  页面布局---->页边距---->常规

  再次选择<页边距>---->自定义页边距---->设置四个方向的边距,勾选<水平><垂直>确定即可

- **5.16 插入页眉和页脚**

  插入---->页眉和页脚---->页眉---->选择样式

  插入---->页眉和页脚---->页脚---->选择样式

- **5.17 自定义页眉页脚**

  插入---->页眉和页脚---->选中第一个页眉框---->图片(选择图片文件)

  插入---->页眉和页脚---->设置突变格式---->大小---->大小和转角---->高度设置1厘米,确定

  选中第二个页眉框输入标题文本

  选中中间页脚位置插入页码

  选中第三个页脚位置插入时间

- **5.18 打印背景图**

  选中打印区域复制

  打开新工作表

  粘贴里面选择<链接的图片>,再次打开打印即可

- **5.19 只打印工作表的图表**

  点击图表,直接打开打印即可

- **5.20 不打印工作表中的0值**

  选中要打印的工作表区域

  文件---->选项---->高级---->此工作表中的显示选项---->取消勾选<在具有0值的单元格中显示0>确定即可,在返回打印

- **5.21 在同一页面打印不同的区域**

  选中要打印的区域一复制

  打开新工作表,粘贴里面选择<链接的图片>

  再次选中要打印的区域二复制

  打开新工作表,粘贴里面选择<链接的图片>

  在返回打印即可



### 6. 数据的保存

- **6.1 在工作表中插入超链接**

  插入---->链接---->在下方地址栏中输入网址,在<要显示的文字>框中输入在Excel单元格显示的名字,点击<屏幕提示>里面输入鼠标移入显示的名字---->确定即可

- **6.2 将Excel文档保存为PDF文件**

  文件---->导出---->创建PDF/XPS文档---->创建PDF/XPS---->选择路径然后点击<发布>即可

- **6.3 将Excel文档发布为网页**

  文件---->另存为---->浏览---->在保存类型下拉选框中选择<网页(*htm,*html)>点击<发布>---->确定即可



## 二、公式与函数

### 1. 公式应用

- **1.1 在工作表中输入公式**

  选中G2单元格输入公式

  ```
  =C2*D2+E2
  ```

  按Enter,然后使用填充功能填充内容

- **1.2 修改公式**

  直接单击公式单元格,重新选择即可

- **1.3 除了使用<=>开头外的其他输入公式**

  在Excel中只要输入<=>符号,Excel会默认你要输入公式

  也有以 + - 开头的,+代表整数,-代表负数,回车Excel会默认在前面加<=>符号进行运算

- **1.4 通过状态栏进行常规计算**

  在Excel最下方的状态栏右键选择计数平均值求和,当你选中一组数据即可在右下方看到结果

- **1.5 连接到其他工作表中的公式**

  注:这个功能主要应用于同类型的表格对比使用

- **1.6 定义单元格名称**

  公式---->定义的名称---->定义名称---->输入名称和引用位置

- **1.7 将公式定义名称**

  公式---->定义的名称---->定义名称---->输入名称和公式

- **1.8 显示应用中的公式**

  公式---->公式审核(显示公式)

- **1.9 对多个单元格执行相同计算**

  在空白单元格输入一个数字,复制

  选中要运算的多个单元区域,在粘贴选项中选择<选择性粘贴>,在里面选择运算的加减乘除,点击确定,即可完成运算



### 2. 常用函数的使用 

#### 2.1 AVERAGE 函数

**求取一组数字的平均值**

语法:

```
AVERAGE(number1, [number2], ...)
AVERAGE 函数语法具有下列参数：
Number1    必需。 要计算平均值的第一个数字、单元格引用或单元格区域。
Number2, ...    可选。 要计算平均值的其他数字、单元格引用或单元格区域，最多可包含 255 个。
返回参数的平均值（算术平均值）。 例如，如果范围A1:A20 包含数字，则公式 =AVERAGE(A1:A20) 将返回这些数字的平均值。
```

公式---->插入函数---->搜索函数(输入:求平均值,转到)---->选择函数:AVERAGE---->确定

函数参数---->Number1(选择要求平均值的选框)---->确定



#### 2.2 COUNT 函数

**统计参数中包含数字的个数**

公式---->自动求和(下拉选框)---->计数---->选择区域



#### 2.3 MAX 函数

**返回一组数字中的最大值**

公式---->自动求和(下拉选框)---->最大值---->选择区域,回车(Enter)即可



#### 2.4 MIN 函数

**返回一组数字中的最小值**

公式---->自动求和(下拉选框)---->最小值---->选择C2到F15区域,回车(Enter)即可



#### 2.5 IF 函数

**根据指定的条件返回不同的结果**

说明:

```
IF 函数是 Excel 中最常用的函数之一，它可以对值和期待值进行逻辑比较。
因此 IF 语句可能有两个结果。 第一个结果是比较结果为 True，第二个结果是比较结果为 False。
```

函数参数:

```
Logical_test(任何可能被计算为TRUE或FALSE的数值或表达式) 
Value_if_true(是Logical_test为TRUE时的返回值,如果忽略,则返回TRUE.IF函数最多嵌套七层 )  
Value_if_false(是当Logical_test为FALSE时的返回值.如果忽略,则返回FALSE )
```

​	公式---->插入函数---->IF(确定)



#### 2.6 SUMIF 函数

**按给定条件对指定单元格求和**

功能: 可以使用 **SUMIF** 函数对 范围 中符合指定条件的值求和。 

语法

```
SUMIF(range, criteria, [sum_range])
SUMIF 函数语法具有以下参数：
range   必需。 要按条件计算的单元格区域。 每个区域中的单元格都必须是数字, 或者是包含数字的名称、数组或引用。 空白和文本值将被忽略。 所选区域可能包含标准 Excel 格式的日期 (下面的示例)。

criteria查询   必需。 定义哪些单元格将被添加的数字、表达式、单元格引用、文本或函数形式的条件。 例如, 条件可以表示为32、">32"、B5、"32"、"苹果" 或 TODAY ()。
	注意: 任何文本条件或任何含有逻辑或数学符号的条件都必须使用双引号 (") 括起来。 如果条件为数字，则无需使		用双引号。

sum_range   可选。 要添加的实际单元格 (如果要添加的单元格不在range参数中指定的单元格)。 如果省略了sum_range参数, 则 Excel 将添加在range参数中指定的单元格 (与应用条件的单元格相同的单元格)。
可以在 criteria 参数中使用通配符 （包括问号 (?) 和星号 (*)）。 问号匹配任意单个字符；星号匹配任意一串字符。 如果要查找实际的问号或星号，请在该字符前键入波形符 (~)。
```

公式---->数学和三角函数---->在下拉选项里面选择<SUMIF>

函数参数:

```
range 加班记录表!$D$3:$D$28
criteria 部门加班费统计!A3
sum_range 加班记录表!$I$3:$I$28
```



#### 2.7 VLOOKUP 函数

**在区域或数组的列中查找数据**

语法:

```
如果需要在表格或区域中按行查找内容，可使用 VLOOKUP，它是一个查找和引用函数。
=VLOOKUP（要查找的值、要在其中查找值的区域、区域中包含返回值的列号、精确匹配或近似匹配 – 指定为 0/FALSE 或 1/TRUE）。
您需要四条信息才能构建 VLOOKUP 语法：
要查找的值，也被称为查阅值。
查阅值所在的区域。 请记住，查阅值应该始终位于所在区域的第一列，这样 VLOOKUP 才能正常工作。 例如，如果查阅值位于单元格 C2 内，那么您的区域应该以 C 开头。
区域中包含返回值的列号。 例如，如果指定 B2：D11 作为区域，那么应该将 B 算作第一列，C 作为第二列，以此类推。
（可选）如果需要返回值的近似匹配，可以指定 TRUE；如果需要返回值的精确匹配，则指定 FALSE。 如果没有指定任何内容，默认值将始终为 TRUE 或近似匹配。
现在将上述所有内容集中在一起，如下所示：
=VLOOKUP（查阅值、包含查阅值的区域、区域中包含返回值的列号以及（可选）为近似匹配指定 TRUE 或者为精确匹配指定 FALSE）。
```

公式---->插入函数---->或选择类别里面选择<查找与引用>----->选择VLOOKUP函数确定

函数参数:

```
Lookup_value:C3  以这个单元格为中心求值

Table_array:Sheet1!B2:G15  选中销售业绩表中的销售信息

Col_index_num: 2  

Range_lookup:FALSE  (FALSE:代表全部查找精准查找,TRUE代表部分查找,一般情况下选择FALSE)
```



#### 2.8 ROUND 函数

用法:ROUND(求值的单元格,保留几位小数)



#### 2.9 公式与函数混合



#### 2.10 嵌套函数

评定结果字段,需求为全年汇总大于30000为优,大于20000为良,否则为差

插入IF函数

```
Logical_test(SUM(C2:F2)>30000) 

Value_if_true("优")

Value_if_false(IF(SUM(C2:F2)>20000,"良","差"))
```



### 3. 文本函数

#### 3.1 EXACT 函数

**比较两个字符串是否相同**

用法:EXACT(值1单元格,值二单元格)



#### 3.2 LEN 函数

**计算文本中的字符个数**

语法格式=Len( text)



#### 3.3 REPT 函数

**按给定次数重复文本**

语法: REPT(text, number_times)

函数语参数：

```
Text   必需。 需要重复显示的文本。

Number_times   必需。 用于指定文本重复次数的正数。
```



#### 3.4 FIXED 函数

**将数字按指定的小数位数取整**

语法

```
FIXED(number, [decimals], [no_commas])
FIXED 函数语法具有下列参数：
- Number    必需。 要进行舍入并转换为文本的数字。
- decimals    可选。 小数点右边的位数。
- no_commas    可选。 一个逻辑值，如果为 TRUE，则会禁止 FIXED 在返回的文本中包含逗号。
```



#### 3.5 LEFT 函数

**从文本左侧起提取指定个数的字符**

语法

```
LEFT(text,num_chars)
Text     是包含要提取字符的文本字符串。
Num_chars    指定要由 LEFT 提取的字符数。Num_chars 必须大于或等于零。如果 num_chars 大于文本长度，则 LEFT 返回所有文本。如果省略 num_chars，则假定其值为 1。
```



#### 3.6 MID 函数

**从文本指定位置起提取指定个数的字符**

语法

```python
MID(text, start_num, num_chars)
文本    必需。 包含要提取字符的文本字符串。
start_num    必需。 文本中要提取的第一个字符的位置。 文本中第一个字符的 start_num 为 1，以此类推。
num_chars    必需。 指定希望 MID 从文本中返回字符的个数。
```



#### 3.7 RIGHT 函数

**从文本右侧起提取指定个数的字符**

语法

```
RIGHT(text,[num_chars])
RIGHTB(text,[num_bytes])
文本    必需。 包含要提取字符的文本字符串。
num_chars    可选。 指定希望 RIGHT 提取的字符数。
```



#### 3.8 ASC 函数

**将全角字符转换为半角字符**

语法: ASC(text)

函数参数：

```
Text    必需。文本或对包含要更改文本的单元格的引用。如果文本不包含任何全角字母，则不会对文本进行转换。
```



#### 3.9 RMB 函数

**将数字转换为带人民币符号￥的文本**

语法:

```
RMB(number, [decimals])
number :需要转换的参数
decimals:保留的小数点位数
```



#### 3.10 T 函数

**将参数转换为文本**

语法

```
T(value)
T 函数语法具有下列参数：
- 值    必需。 要测试的值。
```



#### 3.11 LOWER 函数

**将文本转换为小写**

语法

```
LOWER(text)
LOWER 函数语法具有下列参数：
Text    必需。 要转换为小写字母的文本。 LOWER 不改变文本中的非字母字符。
```



#### 3.12 PROPER 函数

**将文本中每个单词的首字母转换为大写**

语法

```
PROPER(text)
PROPER 函数语法具有下列参数：
文本    必需。 用引号括起来的文本、返回文本值的公式，或者对包含要进行部分大写转换文本的单元格的引用。
```



#### 3.13 FIND 函数

**以字符为单位并区分大小写地查找指定字符的位置**

语法

```
FIND(find_text, within_text, [start_num])
find_text    必需。 要查找的文本。
within_text    必需。 包含要查找文本的文本。
start_num    可选。 指定开始进行查找的字符。 within_text 中的首字符是编号为 1 的字符。 如果省略 start_num，则假定其值为 1。
```



#### 3.14 FINDB 函数

**以字节为单位并区分大小写地查找指定字符的位置**

语法

```
FIND(find_text, within_text, [start_num])
FINDB(find_text, within_text, [start_num])
FIND 和 FINDB 函数语法具有下列参数：
find_text    必需。 要查找的文本。
within_text    必需。 包含要查找文本的文本。
start_num    可选。 指定开始进行查找的字符。 within_text 中的首字符是编号为 1 的字符。 如果省略 start_num，则假定其值为 1。
FIND 适用于使用单字节字符集 (SBCS) 的语言，而 FINDB 适用于使用双字节字符集 (DBCS) 的语言。
```



#### 3.15 SEARCH 函数

**以字符为单位查找指定字符的位置**

语法

```
SEARCH(find_text,within_text,[start_num])
SEARCHB(find_text,within_text,[start_num])
SEARCH 和 SEARCHB 函数具有下列参数：
- **find_text**    必需。要查找的文本。
- **within_text**    必需。要在其中搜索 **find_text** 参数的值的文本。
- **start_num**    可选。**within_text** 参数中从之开始搜索的字符编号。

```



#### 3.16 REPLACE 函数

**以字符为单位根据指定位置进行替换**

语法

```
REPLACE(old_text, start_num, num_chars, new_text)
REPLACEB(old_text, start_num, num_bytes, new_text)
REPLACE 和 REPLACEB 函数语法具有下列参数：
- old_text    必需。 要替换其部分字符的文本。
- start_num    必需。 old_text 中要替换为 new_text 的字符位置。
- num_chars    必需。 old_text 中希望 REPLACE 使用 new_text 来进行替换的字符数。
- Num_bytes    必需。old_text 中希望 REPLACEB 使用 new_text 来进行替换的字节数。
- new_text    必需。 将替换 old_text 中字符的文本。
```



### 5. 逻辑函数

#### 5.1 FALSE 函数

**返回逻辑值 FALSE**



#### 5.2 AND 函数

**判断指定的多个条件是否同时成立**

```
它是一个逻辑函数，用于确定测试中的所有条件是否均为 TRUE。
```



#### 5.3 OR 函数

**判断指定的任一条件是为真，即返回真**

语法

```
它是一个逻辑函数，用于确定测试中的所有条件是否均为 TRUE。
```



#### 5.4 NOT 函数

**对逻辑值求反**

语法

```
如果你想确保一个值不等同于另一值，请使用 NOT 函数
```



#### 5.5 IFERROR 函数

**对错误结果进行处理**

语法

```
IFERROR(value, value_if_error)
IFERROR 函数语法具有下列参数：
值    必需。 检查是否存在错误的参数。
Value_if_error    必需。 公式的计算结果错误时返回的值。 计算以下错误类型：#N/A、#VALUE!、#REF!、#DIV/0!、#NUM!、 #NAME? 或 #NULL!。
```



### 6. 日期与时间函数

#### 6.1 TODAY 函数

**返回当前日期**

语法

```
TODAY()
TODAY 函数语法没有参数。
**注意:** Excel 可将日期存储为可用于计算的连续序列号。 默认情况下，1900 年 1 月 1 日的序列号为 1，2008 年 1 月 1 日的序列号为 39,448，这是因为它距 1900 年 1 月 1 日有 39,447 天。
```



#### 6.2 TIME 函数

**返回某一特定时间的小数值**

语法

```
TIME(hour, minute, second)
TIME 函数语法具有下列参数：
小时    必需。 0（零）到 32767 之间的数字，代表小时。 任何大于 23 的值都会除以 24，余数将作为小时值。 例如，TIME(27,0,0) = TIME(3,0,0) = .125 或 3:00 AM。
分钟    必需。 0 到 32767 之间的数字，代表分钟。 任何大于 59 的值将转换为小时和分钟。 例如，TIME(0,750,0) = TIME(12,30,0) = .520833 或 12:30 PM。
秒    必需。 0 到 32767 之间的数字，代表秒。 任何大于 59 的值将转换为小时、分钟和秒。 例如，TIME(0,0,2000) = TIME(0,33,22) = .023148 或 12:33:20 AM
```



#### 6.3 YEAR 函数

**返回某日期对应的年份**

语法

```
YEAR(serial_number)
YEAR 函数语法具有下列参数：
Serial_number    必需。 要查找的年份的日期。 应使用 DATE 函数输入日期，或者将日期作为其他公式或函数的结果输入。 例如，使用函数 DATE(2008,5,23) 输入 2008 年 5 月 23 日。 如果日期以文本形式输入，则会出现问题。
```



#### 6.4 MONTH 函数

**返回某日期对应的月份**

语法

```
MONTH(serial_number)
MONTH 函数语法具有下列参数：
Serial_number    必需。要查找的月份日期。应使用 DATE 函数输入日期，或将日期作为其他公式或函数的结果输入。例如，使用函数 DATE(2008,5,23) 输入 2008 年 5 月 23 日。如果日期以文本形式输入，则会出现问题。
返回日期（以序列数表示）中的月份。 月份是介于 1（一月）到 12（十二月）之间的整数。
```



#### 6.5 DAYS360 函数

**以360天为准计算两个日期间天数**

语法

```
DAYS360(start_date,end_date,[method])
DAYS360 函数语法具有下列参数：
Start_date、end_date    必需。 用于计算期间天数的起止日期。 如果 start_date 在 end_date 之后，则 DAYS360 函数将返回一个负数。 应使用 DATE 函数输入日期，或者将从其他公式或函数派生日期。 例如，使用函数 DATE(2008,5,23) 以返回 2008 年 5 月 23 日。 如果日期以文本形式输入，则会出现问题。
方法    可选。 逻辑值，用于指定在计算中是采用美国方法 还是欧洲方法。
按照一年 360 天的算法（每个月以 30 天计，一年共计 12 个月），DAYS360 函数返回两个日期间相差的天数，这在一些会计计算中将会用到。 如果财会系统是基于一年 12 个月，每月 30 天，可使用此函数帮助计算支付款项。
```



#### 6.6 NETWORKDAYS 函数

**计算日期间所有工作日数**

语法

```
NETWORKDAYS(start_date, end_date, [holidays])
NETWORKDAYS 函数语法具有下列参数：
Start_date    必需。 一个代表开始日期的日期。
End_date    必需。 一个代表终止日期的日期。
Holidays    可选。不在工作日历中的一个或多个日期所构成的可选区域，例如：省/市/自治区和国家/地区的法定假日以及其他非法定假日。该列表可以是包含日期的单元格区域，或是表示日期的序列号的数组常量。
返回参数 start_date 和 end_date 之间完整的工作日数值。 工作日不包括周末和专门指定的假期。 可以使用函数 NETWORKDAYS，根据某一特定时期内雇员的工作天数，计算其应计的报酬。
```



#### 6.7 WORKDAY 函数

**计算指定日期向前或向后数个工作日后的日期**

语法

```
WORKDAY(start_date, days, [holidays])
WORKDAY 函数语法具有下列参数：
Start_date    必需。 一个代表开始日期的日期。
Days    必需。 start_date 之前或之后不含周末及节假日的天数。 Days 为正值将生成未来日期；为负值生成过去日期。
Holidays    可选。一个可选列表，其中包含需要从工作日历中排除的一个或多个日期，例如各种省/市/自治区和国家/地区的法定假日及非法定假日。该列表可以是包含日期的单元格区域，也可以是由代表日期的序列号所构成的数组常量。
重要: 应使用 DATE 函数输入日期，或者将日期作为其他公式或函数的结果输入。 例如，使用函数 DATE(2008,5,23) 输入 2008 年 5 月 23 日。 如果日期以文本形式输入，则会出现问题。
返回在某日期（起始日期）之前或之后、与该日期相隔指定工作日的某一日期的日期值。 工作日不包括周末和专门指定的假日。 在计算发票到期日、预期交货时间或工作天数时，可以使用函数 WORKDAY 来扣除周末或假日。
```



#### 6.8 YEARFRAC 函数

**计算从开始日期到结束日期所经历的天数占全年天数的**

语法

```
YEARFRAC(start_date, end_date, [basis])
YEARFRAC 函数语法具有下列参数：
Start_date    必需。 一个代表开始日期的日期。
End_date    必需。 一个代表终止日期的日期。
Basis    可选。 要使用的日计数基准类型。
Basis			日计数基准
0 或省略		  US (NASD) 30/360
1				实际/实际
2				实际/360
3				实际/365
4				欧洲 30/36
重要: 
应使用 DATE 函数输入日期，或者将日期作为其他公式或函数的结果输入。 例如，使用函数 DATE(2018,5,23) 输入 2018 年 5 月 23 日。 如果日期以文本形式输入，则会出现问题。
如果使用 US (NASD) 30/360 基准，且 start_date 是二月的最后一天，则 YEARFRAC 函数可能会返回错误的结果。
YEARFRAC 可计算两个日期（start_date 和 end_date）之间的天数（取整天数）占一年的比例。 例如，可使用 YEARFRAC 确定某一特定条件下全年效益或债务的比例。
```



### 7. 查找与引用函数

#### 7.1 CHOOSE 函数

**根据序号从列表中选择对应的内容**

语法

```
CHOOSE(index_num, value1, [value2], ...)
CHOOSE 函数语法具有以下参数：
index_num    必需。 用于指定所选定的数值参数。 index_num 必须是介于 1 到 254 之间的数字，或是包含 1 到 254 之间的数字的公式或单元格引用。
如果 index_num 为 1，则 CHOOSE 返回 value1；如果为 2，则 CHOOSE 返回 value2，以此类推。
如果 index_num 小于 1 或大于列表中最后一个值的索引号，则 CHOOSE 返回 #VALUE! 错误值。
如果 index_num 为小数，则在使用前将被截尾取整。
value1, value2, ...    Value1 是必需的，后续值是可选的。 1 到 254 个数值参数，CHOOSE 将根据 index_num 从中选择一个数值或一项要执行的操作。 参数可以是数字、单元格引用、定义的名称、公式、函数或文本
使用 index_num 返回数值参数列表中的数值。 使用 CHOOSE 可以根据索引号从最多 254 个数值中选择一个。 例如，如果 value1 到 value7 表示一周的 7 天，那么将 1 到 7 之间的数字用作 index_num 时，CHOOSE 将返回其中的某一天。
```



#### 7.2 HLOOKUP 函数

**在区域或数组的行中查找数据**

语法

```
HLOOKUP(lookup_value, table_array, row_index_num, [range_lookup])
HLOOKUP 函数语法具有下列参数：
Lookup_value    必需。 要在表格的第一行中查找的值。 Lookup_value 可以是数值、引用或文本字符串。
Table_array    必需。 在其中查找数据的信息表。 使用对区域或区域名称的引用。
Table_array 的第一行的数值可以为文本、数字或逻辑值。
如果 range_lookup 为 TRUE，则 table_array 的第一行的数值必须按升序排列：...-2、-1、0、1、2、...、A-Z、FALSE、TRUE；否则，HLOOKUP 将不能给出正确的数值。 如果 range_lookup 为 FALSE，则 table_array 不必进行排序。
文本不区分大小写。
将数值从左到右按升序排序。有关详细信息，请参阅对区域或表中的数据排序。
Row_index_num    必需。 table_array 中将返回的匹配值的行号。 row_index_num 为 1 时，返回 table_array 的第一行的值；row_index_num 为 2 时，返回 table_array 第二行中的值，依此类推。 如果 row_index_num 小于 1，则 HLOOKUP 返回 错误值 #VALUE!；如果 row_index_num 大于 table_array 的行数，则 HLOOKUP 返回 错误值 #REF!。
Range_lookup    可选。 一个逻辑值，指定希望 HLOOKUP 查找精确匹配值还是近似匹配值。 如果为 TRUE 或省略，则返回近似匹配值。 换言之，如果找不到精确匹配值，则返回小于 lookup_value 的最大值。 如果为 False，则 HLOOKUP 将查找精确匹配值。 如果找不到精确匹配值，则返回错误值 #N/A。
```



#### 7.3 LOOKUP 函数

**以向量形式在单行单列中查找**

语法:

```
LOOKUP(lookup_value, lookup_vector, [result_vector])
LOOKUP 函数向量形式语法具有以下参数：
lookup_value    必需。 LOOKUP 在第一个向量中搜索的值。 Lookup_value 可以是数字、文本、逻辑值、名称或对值的引用。
lookup_vector    必需。 只包含一行或一列的区域。 lookup_vector 中的值可以是文本、数字或逻辑值。
重要: lookup_vector 中的值必须按升序排列：..., -2, -1, 0, 1, 2, ..., A-Z, FALSE, TRUE；否则，LOOKUP 可能无法返回正确的值。 文本不区分大小写。
result_vector    可选。只包含一行或一列的区域。result_vector 参数必须与 lookup_vector 参数大小相同。其大小必须相同。
```



#### 7.4 MATCH 函数

**返回指定内容所在的位置**

语法

```
MATCH(lookup_value, lookup_array, [match_type])
MATCH 函数语法具有下列参数：
lookup_value    必需。 要在 lookup_array 中匹配的值。 例如，如果要在电话簿中查找某人的电话号码，则应该将姓名作为查找值，但实际上需要的是电话号码。
lookup_value 参数可以为值（数字、文本或逻辑值）或对数字、文本或逻辑值的单元格引用。
lookup_array    必需。 要搜索的单元格区域。
match_type    可选。 数字 -1、0 或 1。 match_type 参数指定 Excel 如何将 lookup_value 与 lookup_array 中的值匹配。 此参数的默认值为 1。
```



#### 7.5 TRANSPOSE 函数

**转置数据区域的行列位置**

语法

```
TRANSPOSE(array)
TRANSPOSE 函数语法具有以下参数：
数组   必备.要转置的工作表上的数组或单元格区域。通过使用数组的第一行作为新数组的第一列, 数组的第二行作为新数组的第二列, 依此类推, 创建数组的转置。如果你不确定如何输入数组公式, 请参阅创建数组公式。
```



#### 7.6 INDIRECT 函数

**返回由文本值指定的引用**

语法

```
INDIRECT(ref_text, [a1])
INDIRECT 函数语法具有以下参数：
Ref_text    必需。对单元格的引用，此单元格包含 A1 样式的引用、R1C1 样式的引用、定义为引用的名称或对作为文本字符串的单元格的引用。如果 ref_text 不是合法的单元格引用，则 INDIRECT 返回 错误值。
如果 ref_text 是对另一个工作簿的引用（外部引用），则被引用的工作簿必须已打开。如果源工作簿没有打开，则 INDIRECT 返回错误值 #REF!。
注意    Excel Web App 中不支持外部引用。
如果 ref_text 引用的单元格区域超出 1,048,576 这一行限制或 16,384 (XFD) 这一列限制，则 INDIRECT 返回错误 #REF!。
注意    此行为不同于 Microsoft Office Excel 2007 之前的 Excel 版本，早期的版本会忽略超出的限制并返回一个值。
A1    可选。一个逻辑值，用于指定包含在单元格 ref_text 中的引用的类型。
如果 a1 为 TRUE 或省略，ref_text 被解释为 A1-样式的引用。
如果 a1 为 FALSE，则将 ref_text 解释为 R1C1 样式的引用。
返回由文本字符串指定的引用。此函数立即对引用进行计算，并显示其内容。如果需要更改公式中对单元格的引用，而不更改公式本身，请使用函数 INDIRECT。
```



### 8. 财务函数

#### 8.1 FV 函数

**计算一笔投资的期值**

语法

```
FV(rate,nper,pmt,[pv],[type])
有关函数 FV 中各参数以及年金函数的详细信息，请参阅函数 PV。
FV 函数语法具有下列参数：
Rate    必需。 各期利率。
Nper    必需。年金的付款总期数。
Pmt    必需。 各期所应支付的金额，在整个年金期间保持不变。 通常 pmt 包括本金和利息，但不包括其他费用或税款。 如果省略 pmt，则必须包括 pv 参数。
pv    可选。 现值，或一系列未来付款的当前值的累积和。 如果省略 pv，则假定其值为 0（零），并且必须包括 pmt 参数。
Type    可选。 数字 0 或 1，用以指定各期的付款时间是在期初还是期末。 如果省略 type，则假定其值为 0。
FV 是一个财务函数，用于根据固定利率计算投资的未来值。 可以将 FV 与定期付款、固定付款或一次付清总额付款结合使用。
```



#### 8.2 PV 函数

**计算投资的现值**

语法

```
PV(rate, nper, pmt, [fv], [type])
PV 函数语法具有下列参数：
Rate    必需。 各期利率。 例如，如果您获得年利率为 10% 的汽车贷款，并且每月还款一次，则每月的利率为 10%/12（即 0.83%）。 您需要在公式中输入 10%/12（即 0.83%）或 0.0083 作为利率。
Nper    必需。 年金的付款总期数。 例如，如果您获得为期四年的汽车贷款，每月还款一次，则贷款期数为 4*12（即 48）期。 您需要在公式中输入 48 作为 nper。
Pmt    必需。 每期的付款金额，在年金周期内不能更改。 通常，pmt 包括本金和利息，但不含其他费用或税金。 例如，对于金额为 ￥100,000、利率为 12% 的四年期汽车贷款，每月付款为 ￥2633.30。 您需要在公式中输入 -2633.30 作为 pmt。 如果省略 pmt，则必须包括 fv 参数。
fv    可选。 未来值，或在最后一次付款后希望得到的现金余额。 如果省略 fv，则假定其值为 0（例如，贷款的未来值是 0）。 例如，如果要在 18 年中为支付某个特殊项目而储蓄 ￥500,000，则 ￥500,000 就是未来值。 然后，您可以对利率进行保守的猜测，并确定每月必须储蓄的金额。 如果省略 fv，则必须包括 pmt 参数。
类型    可选。 数字 0 或 1，用以指定各期的付款时间是在期初还是期末。
PV 是一个财务函数，用于根据固定利率计算贷款或投资的现值。 可以将 PV 与定期付款、固定付款（如按揭或其他贷款）或投资目标的未来值结合使用。
```



#### 8.3 RATE 函数

**计算年金的各期利率**

语法

```
RATE(nper, pmt, pv, [fv], [type], [guess])
注意: 有关参数 nper、pmt、pv、fv 和 type 的详细说明，请参阅 PV。
RATE 函数语法具有下列参数：
Nper    必需。年金的付款总期数。
Pmt    必需。 每期的付款金额，在年金周期内不能更改。 通常，pmt 包括本金和利息，但不含其他费用或税金。 如果省略 pmt，则必须包括 fv 参数。
pv    必需。现值即一系列未来付款当前值的总和。
Fv    可选。未来值，或在最后一次付款后希望得到的现金余额。如果省略 fv，则假定其值为 0（例如，贷款的未来值是 0）。如果省略 fv，则必须包括 pmt 参数。
类型    可选。 数字 0 或 1，用以指定各期的付款时间是在期初还是期末。
Guess    可选。 预期利率。
如果省略 guess，则假定其值为 10%。
如果 RATE 不能收敛，请尝试不同的 guess 值。 如果 guess 在 0 和 1 之间，RATE 通常会收敛。
```



#### 8.4 NPER 函数

**计算还款次数**

语法

```
NPER(rate,pmt,pv,[fv],[type])
有关 NPER 中各参数的详细说明及有关年金函数的详细信息，请参阅 PV。
NPER 函数语法具有下列参数：
Rate    必需。 各期利率。
Pmt    必需。 各期所应支付的金额，在整个年金期间保持不变。 通常 pmt 包括本金和利息，但不包括其他费用或税款。
Pv    必需。 现值，或一系列未来付款的当前值的累积和。
Fv    可选。 未来值，或在最后一次付款后希望得到的现金余额。 如果省略 fv，则假定其值为 0（例如，贷款的未来值是 0）。
类型    可选。 数字 0 或 1，用以指定各期的付款时间是在期初还是期末。
基于固定利率及等额分期付款方式，返回某项投资的总期数。
```



#### 8.5 PMT 函数

**计算贷款的每期付款额**

语法

```
PMT(rate, nper, pv, [fv], [type])
注意: 有关 PMT 参数的更完整的说明，请参阅 PV 函数。
PMT 函数语法具有下列参数：
rate    必需。 贷款利率。
Nper    必需。 该项贷款的付款总数。
pv    必需。 现值，或一系列未来付款额现在所值的总额，也叫本金。
fv    可选。 未来值，或在最后一次付款后希望得到的现金余额。 如果省略 fv，则假定其值为 0（零），即贷款的未来值是 0。
类型    可选。 数字 0（零）或 1 指示支付时间。
PMT 是一个财务函数，用于根据固定付款额和固定利率计算贷款的付款额。
```



#### 8.6 IPMT 函数

**计算贷款在给定期间内支付的利息**

语法

```
IPMT(rate, per, nper, pv, [fv], [type])
IPMT 函数语法具有以下参数：
Rate    必需。 各期利率。
Per    必需。 用于计算其利息数额的期数，必须在 1 到 nper 之间。
Nper    必需。年金的付款总期数。
Pv    必需。 现值，或一系列未来付款的当前值的累积和。
Fv    可选。 未来值，或在最后一次付款后希望得到的现金余额。 如果省略 fv，则假定其值为 0（例如，贷款的未来值是 0）。
Type    可选。 数字 0 或 1，用以指定各期的付款时间是在期初还是期末。 如果省略 type，则假定其值为 0。
基于固定利率及等额分期付款方式，返回给定期数内对投资的利息偿还额。
```



#### 14.7 PPMT 函数

**计算贷款在给定期间内偿还的本金**

语法

```
PPMT(rate, per, nper, pv, [fv], [type])
注意: 有关 PPMT 中参数的详细说明，请参阅 PV。
PPMT 函数语法具有下列参数：
Rate    必需。 各期利率。
per    必需。 指定期数，该值必须在 1 到 nper 范围内。
Nper    必需。年金的付款总期数。
pv    必需。现值即一系列未来付款当前值的总和。
fv    可选。 未来值，或在最后一次付款后希望得到的现金余额。 如果省略 fv，则假定其值为 0（零），即贷款的未来值是 0。
类型    可选。 数字 0 或 1，用以指定各期的付款时间是在期初还是期末。
返回根据定期固定付款和固定利率而定的投资在已知期间内的本金偿付额。
```



#### 8.8 ISPMT 函数

**计算特定投资期内支付的利息**

语法

```
ISPMT(rate, per, nper, pv)
ISPMT 函数语法具有下列参数：
参数			描述
费率			必填。投资利率。
Per			  必填。为其您想要查找感兴趣，并且必须介于 1 到 Nper 之间时间段。
Nper		  必填。投资的付款期总数。
Pv			  必填。投资的现值。对于贷款，Pv 是贷款金额。
计算利率支付 （或接收） 给定期间内的贷款 （或投资） 甚至本金付款。
```



#### 8.9 CUMIPMT 函数

**计算两个付款期之间累积支付的利息**

语法

```
CUMIPMT(rate, nper, pv, start_period, end_period, type)
CUMIPMT 函数语法具有下列参数：
Rate    必需。 利率。
Nper    必需。 总付款期数。
pv    必需。 现值。
Start_period    必需。 计算中的首期。 付款期数从 1 开始计数。
End_period    必需。 计算中的末期。
Type    必需。 付款时间类型。
返回一笔贷款在给定的 start_period 到 end_period 期间累计偿还的利息数额。
```



#### 8.10 CUMPRINC 函数

**计算两个付款期之间累积支付的本金**

语法

```
CUMPRINC(rate, nper, pv, start_period, end_period, type)
CUMPRINC 函数语法具有下列参数：
Rate    必需。 利率。
Nper    必需。 总付款期数。
pv    必需。 现值。
Start_period    必需。 计算中的首期。 付款期数从 1 开始计数。
End_period    必需。 计算中的末期。
Type    必需。 付款时间类型。
返回一笔贷款在给定的 start_period 到 end_period 期间累计偿还的本金数额。
```



#### 8.11 FVSCHEDULE 函数

**使用一系列复利率计算初始本金的未来值**

语法

```
FVSCHEDULE(principal, schedule)
FVSCHEDULE 函数语法具有下列参数：
Principal    必需。 现值。
计划    必需。 要应用的利率数组。
返回应用一系列复利率计算的初始本金的未来值。 使用 FVSCHEDULE 通过变量或可调节利率计算某项投资未来的价值。
```



#### 8.12 NPV 函数

**基于一系列定期的现金流和贴现率，计算投资的净现值**

语法

```
NPV(rate,value1,[value2],...)
NPV 函数语法具有下列参数：
rate    必需。某一期间的贴现率。
value1, value2, ...    Value1 是必需的，后续值是可选的。这些是代表支出及收入的 1 到 254 个参数。
Value1, value2, ...在时间上必须具有相等间隔，并且都发生在期末。
NPV 使用 value1, value2,... 的顺序来说明现金流的顺序。一定要按正确的顺序输入支出值和收益值。
忽略以下类型的参数：参数为空白单元格、逻辑值、数字的文本表示形式、错误值或不能转化为数值的文本。
如果参数是一个数组或引用，则只计算其中的数字。数组或引用中的空白单元格、逻辑值、文本或错误值将被忽略。
使用贴现率和一系列未来支出（负值）和收益（正值）来计算一项投资的净现值。
```



#### 8.13 XNPV 函数

**计算一组未必定期发生的现金流的净现值**

语法

```
XNPV(rate, values, dates)
XNPV 函数语法具有下列参数：
Rate    必需。 应用于现金流的贴现率。
值    必需。 与 dates 中的支付时间相对应的一系列现金流。 首期支付是可选的，并与投资开始时的成本或支付有关。 如果第一个值是成本或支付，则它必须是负值。 所有后续支付都基于 365 天/年贴现。 数值系列必须至少要包含一个正数和一个负数。
日期    必需。 与现金流支付相对应的支付日期表。 第一个支付日期代表支付表的开始日期。 其他所有日期应晚于该日期，但可按任何顺序排列。
```



#### 8.14 IRR 函数

**计算一系列现金流的内部收益率**

语法

```
IRR(values, [guess])
IRR 函数语法具有下列参数：
Values    必需。 数组或单元格的引用，这些单元格包含用来计算内部收益率的数字。
Values 必须包含至少一个正值和一个负值，以计算返回的内部收益率。
IRR 使用值的顺序来说明现金流的顺序。 一定要按您需要的顺序输入支出值和收益值。
如果数组或引用包含文本、逻辑值或空白单元格，这些数值将被忽略。
Guess    可选。 对函数 IRR 计算结果的估计值。
Microsoft Excel 使用迭代法计算函数 IRR。 从 guess 开始，IRR 不断修正计算结果，直至其精度小于 0.00001%。 如果 IRR 运算 20 次，仍未找到结果，则返回 错误值 #NUM!。
多数情况下，不必为 IRR 计算提供 guess 值。 如果省略 guess，则假定它为 0.1 (10%)。
如果 IRR 返回 错误值 #NUM!，或结果不接近您预期的值，可用另一个 guess 值重试。
返回由值中的数字表示的一系列现金流的内部收益率。 这些现金流不必等同，因为它们可能作为年金。 但是，现金流必须定期（如每月或每年）出现。 内部收益率是针对包含付款（负值）和收入（正值）的定期投资收到的利率。
```



#### 8.15 MIRR 函数

**计算正负现金流在不同利率下支付的内部收益率**

语法

```
MIRR(values, finance_rate, reinvest_rate)
MIRR 函数语法具有下列参数：
Values    必需。 数组或对包含数字的单元格的引用。 这些数值代表一系列定期支出（负值）和收益（正值）。
值必须包含至少一个正值和一个负值, 以计算修改后的内部收益率。 否则, MIRR 将返回 #DIV/0! 错误值。
如果数组或引用参数包含文本、逻辑值或空白单元格，则这些值将被忽略；但包含零值的单元格将计算在内。
Finance_rate    必需。 现金流中使用的资金支付的利率。
Reinvest_rate    必需。 将现金流再投资的收益率。
返回一系列定期现金流的已修改内部收益率。 MIRR 认为投资的成本和 reinvestment 在现金上收到的利息。
```



#### 8.16 XIRR 函数

**计算一组未必定期发生的现金流的内部收益率**

语法

```
XIRR(values, dates, [guess])
XIRR 函数语法具有下列参数：
值    必需。 与 dates 中的支付时间相对应的一系列现金流。 首期支付是可选的，并与投资开始时的成本或支付有关。 如果第一个值是成本或支付，则它必须是负值。 所有后续支付都基于 365 天/年贴现。 值系列中必须至少包含一个正值和一个负值。
日期    必需。 与现金流支付相对应的支付日期表。 日期可按任何顺序排列。 应使用 DATE 函数输入日期，或者将日期作为其他公式或函数的结果输入。 例如，使用函数 DATE(2008,5,23) 输入 2008 年 5 月 23 日。 如果日期以文本形式输入，则会出现问题 。
Guess    可选。 对函数 XIRR 计算结果的估计值。
返回一组不一定定期发生的现金流的内部收益率。 若要计算一组定期现金流的内部收益率，请使用函数 IRR。
```



#### 8.17 AMORDEGRC 函数

**根据资产的耐用年限，计算每个结算期间的折旧值**

语法

```
AMORDEGRC(cost, date_purchased, first_period, salvage, period, rate, [basis])
重要: 应使用 DATE 函数输入日期，或者将日期作为其他公式或函数的结果输入。 例如，使用函数 DATE(2008,5,23) 输入 2008 年 5 月 23 日。 如果日期以文本形式输入，则会出现问题。
AMORDEGRC 函数语法具有下列参数：
Cost    必需。 资产原值。
Date_purchased    必需。 购入资产的日期。
First_period    必需。 第一个期间结束时的日期。
Salvage    必需。 资产在使用寿命结束时的残值。
Period    必需。 期间。
Rate    必需。 折旧率。
Basis    可选。 要使用的年基准。
返回每个结算期间的折旧值。 该函数主要为法国会计系统提供。 如果某项资产是在该结算期的中期购入的，则按直线折旧法计算。 该函数与函数 AMORLINC 相似，不同之处在于该函数中用于计算的折旧系数取决于资产的寿命。
```



#### 8.18  DB 函数

**使用固定余额递减法，计算一笔资产在给定期间内的折旧值**

语法

```
DB(cost, salvage, life, period, [month])
DB 函数语法具有下列参数：
Cost    必需。 资产原值。
Salvage    必需。 折旧末尾时的值（有时也称为资产残值）。
Life    必需。 资产的折旧期数（有时也称作资产的使用寿命）。
Period    必需。 您要计算折旧的时期。 Period 必须使用与 life 相同的单位。
Month    可选。 第一年的月份数。 如果省略月份，则假定其值为 12。
使用固定余额递减法，计算一笔资产在给定期间内的折旧值。
```



#### 8.19 DDB 函数

**使用双倍余额递减法或其他指定方法，计算一笔资产在给定期间内的折旧值**

语法

```
DDB(cost, salvage, life, period, [factor])
DDB 函数语法具有下列参数：
Cost    必需。 资产原值。
Salvage    必需。 折旧末尾时的值（有时也称为资产残值）。 该值可以是 0。
Life    必需。 资产的折旧期数（有时也称作资产的使用寿命）。
Period    必需。 您要计算折旧的时期。 Period 必须使用与 life 相同的单位。
Factor    可选。 余额递减速率 如果省略 factor，则假定其值为 2（双倍余额递减法）。
重要: 这五个参数都必须是正数。
用双倍余额递减法或其他指定方法，返回指定期间内某项固定资产的折旧值。
```



#### 8.20 VDB 函数

**使用余额递减法，计算一笔资产在给定期间或部分期间内的折旧值**

语法

```
VDB(cost, salvage, life, start_period, end_period, [factor], [no_switch])
VDB 函数语法具有下列参数：
Cost    必需。 资产原值。
Salvage    必需。 折旧末尾时的值（有时也称为资产残值）。 该值可以是 0。
Life    必需。 资产的折旧期数（有时也称作资产的使用寿命）。
Start_period    必需。 您要计算折旧的起始时期。 Start_period 必须与 life 使用相同的单位。
End_period    必需。 您要计算折旧的终止时期。 End_period 必须与 life 使用相同的单位。
Factor    可选。 余额递减速率。 如果省略影响因素，则假定为 2（双倍余额递减法）。 如果不想使用双倍余额递减法，请更改余额递减速率。 有关双倍余额递减法的说明，请参阅 DDB。
No_switch    可选。 逻辑值，指定当折旧值大于余额递减计算值时，是否转用直线折旧法。
如果 no_switch 为 TRUE，即使折旧值大于余额递减计算值，Microsoft Excel 也不转用直线折旧法。
如果 no_switch 为 FALSE 或被忽略，且折旧值大于余额递减计算值时，Excel 将转用线性折旧法。
重要: 除 no_switch 外的所有参数必须为正数。
使用双倍余额递减法或其他指定方法，返回一笔资产在给定期间（包括部分期间）内的折旧值。 函数 VDB 代表可变余额递减法。
```



#### 8.21 SLN 函数

**计算某项资产在一个期间内的线性折旧值**

语法

```
SLN(cost, salvage, life)
SLN 函数语法具有下列参数：
Cost    必需。 资产原值。
Salvage    必需。 折旧末尾时的值（有时也称为资产残值）。
Life    必需。 资产的折旧期数（有时也称作资产的使用寿命）。
返回一个期间内的资产的直线折旧。
```



#### 8.22 SYD 函数

计算某项资产按年限总和折旧法计算的指定期间的折旧值

语法

```
SYD(cost, salvage, life, per)
SYD 函数语法具有下列参数：
<c0>Cost</c0>    必需。 资产原值。
<c0>Salvage</c0>    必需。 折旧末尾时的值（有时也称为资产残值）。
<c0>Life</c0>    必需。 资产的折旧期数（有时也称作资产的使用寿命）。
<c0>per</c0>    必需。 期间，必须与 life 使用相同的单位。
返回在指定期间内资产按年限总和折旧法计算的折旧。
```



### 9. 数学和三角函数

#### 9.1 SQRT 函数

**计算正平方根**

语法

```
SQRT(number)
SQRT 函数语法具有下列参数：
Number    必需。 要计算其平方根的数字。
返回正的平方根。
```



#### 9.2 QUOTIENT 函数

**返回商的整数部分**

语法

```
QUOTIENT(numerator, denominator)
QUOTIENT 函数语法具有下列参数：
Numerator    必需。 被除数。
Denominator    必需。 除数。
返回除法的整数部分。 要放弃除法的余数时，可使用此函数。
```



#### 9.3 SUMPRODUCT 函数

**计算数组元素的乘积之和**

语法

```
SUMPRODUCT(array1, [array2], [array3], ...)
SUMPRODUCT 函数语法具有下列参数：
Array1    必需。 其相应元素需要进行相乘并求和的第一个数组参数。
Array2, array3,...    可选。 2 到 255 个数组参数，其相应元素需要进行相乘并求和。
在给定的几组数组中，将数组间对应的元素相乘，并返回乘积之和。
```



#### 9.4 SUMSQ 函数

**计算参数的平方和**

语法

```
SUMSQ(number1, [number2], ...)
SUMSQ 函数语法具有下列参数：
number1, number2, ...    Number1 是必需的，后续数字是可选的。 要对其求平方和的 1 到 255 个参数。 也可以用单一数组或对某个数组的引用来代替用逗号分隔的参数。
返回参数的平方和。
```



#### 9.5 CEILING 函数

**按条件向上舍入**

语法

```
CEILING(number, significance)
CEILING 函数语法具有以下参数：
Number    必需。 要舍入的值。
significance    必需。 要舍入到的倍数。
返回将参数 number 向上舍入（沿绝对值增大的方向）为最接近的指定基数的倍数。 例如，如果您不希望在价格使用所有“分”值，当产品价格为 $4.42 时，则可以使用公式 =CEILING(4.42,0.05) 将价格向上舍入到最接近的 5 美分。
```



#### 9.6 FLOOR 函数

**按条件向下舍入**

语法

```
FLOOR(number, significance)
FLOOR 函数语法具有下列参数：
Number    必需。 要舍入的数值。
significance    必需。 要舍入到的倍数.
将参数 number 向下舍入（沿绝对值减小的方向）为最接近的 significance 的倍数。
```



#### 9.7 SIGN 函数

**获取数值的符号**

语法

```
SIGN(number)
SIGN 函数语法具有下列参数：
Number    必需。 任意实数。
确定数字的符号。 如果数字为正数，则返回 1；如果数字为 0，则返回零 (0)；如果数字为负数，则返回 -1。
```



#### 9.8 MOD 函数

**计算两数相除的余数**

语法

```
MOD(number, divisor)
MOD 函数语法具有下列参数：
Number    必需。 要计算余数的被除数。
Divisor    必需。 除数。
返回两数相除的余数。 结果的符号与除数相同。
```



### 10. 其他函数

#### 10.1 COUNTA 函数

**计算参数中包含非空值的个数**

语法

```
COUNTA(value1, [value2], ...)
COUNTA 函数语法具有下列参数：
value1    必需。 表示要计数的值的第一个参数。
value2, ...    可选。 表示要计数的值的其他参数，最多可包含 255 个参数。
COUNTA 函数计算范围中不为空的单元格的个数。
```



#### 10.2 COUNTBLANK 函数

**计算区域中空白单元格的个数**

语法

```
COUNTBLANK（区域）
COUNTBLANK函数语法具有下列参数：
范围    必需。 需要计算其中空白单元格个数的区域。
COUNTBLANK函数，其中一个统计函数，用于计算单元格区域中的空单元格的个数。
```



#### 10.3 COUNTIF 函数

**计算满足给定条件的单元格的个数**

语法

```
COUNTIF(range, criteria)
参数名称				说明
range（必需）			要进行计数的单元格组。 区域可以包括数字、数组、命名区域或包含数字的引用。 空白和					    文本值将被忽略。
					   了解如何选择工作表中的区域。
criteria   （必需）       用于决定要统计哪些单元格的数量的数字、表达式、单元格引用或文本字符串。
						例如，可以使用 32 之类数字，“>32”之类比较，B4 之类单元格，或“苹果”之类单词。
					    COUNTIF 仅使用一个条件。 如果要使用多个条件，请使用 COUNTIFS。
COUNTIF 是一个统计函数，用于统计满足某个条件的单元格的数量；例如，统计特定城市在客户列表中出现的次数。
```



#### 10.4 COUNTIFS 函数

**计算满足多个给定条件的单元格的个数**

语法

```
COUNTIFS(criteria_range1, criteria1, [criteria_range2, criteria2],…)
COUNTIFS 函数语法具有以下参数：
<c0>criteria_range1</c0>    必需。 在其中计算关联条件的第一个区域。
<c0>criteria1</c0>    必需。 条件的形式为数字、表达式、单元格引用或文本，它定义了要计数的单元格范围。 例如，条件可以表示为 32、">32"、B4、"apples"或 "32"。
<c0>criteria_range2, criteria2, ...</c0>    可选。 附加的区域及其关联条件。 最多允许 127 个区域/条件对。
COUNTIFS 函数将条件应用于跨多个区域的单元格，然后统计满足所有条件的次数。
```



#### 10.5 SUMIFS 函数

**计算多重条件的和**

语法

```
SUMIFS(sum_range, criteria_range1, criteria1, [criteria_range2, criteria2], ...)
参数名称					说明
Sum_range（必需）			 要求和的单元格区域。
Criteria_range1（必需）		  使用 Criteria1 测试的区域。
							Criteria_range1 和 Criteria1 设置用于搜索某个区域是否符合特定条件的搜索							 对。 一旦在该区域中找到了项，将计算 Sum_range 中的相应值的和。
							
Criteria1（必需）			定义将计算 Criteria_range1 中的哪些单元格的和的条件。 例如，可以将条件输入							为 32、">32"、B4、"苹果" 或 "32"。

Criteria_range2, 			附加的区域及其关联条件。 最多可以输入 127 个区域/条件对。
criteria2, …    (optional)
SUMIFS 函数是一个数学与三角函数，用于计算其满足多个条件的全部参数的总量。 例如，可以使用 SUMIFS 计算一个国家/地区内 (1) 邮政编码为同一个且 (2) 利润超过了特定美元值的零售商的总量。
```



#### 10.6 AVERAGEA 函数

**计算参数中非空值的平均值**

语法

```
AVERAGEA(value1, [value2], ...)
AVERAGEA 函数语法具有以下参数：
Value1, value2, ...    Value1 是必需的，后续值是可选的。 需要计算平均值的 1 到 255 个单元格、单元格区域或值。
计算参数列表中数值的平均值（算术平均值）。
```



#### 10.7 AVERAGEIF 函数

**计算满足给定条件的单元格的平均值**

语法

```
AVERAGEIF(range, criteria, [average_range])
AVERAGEIF 函数语法具有下列参数：
Range    必需。 要计算平均值的一个或多个单元格，其中包含数字或包含数字的名称、数组或引用。
Criteria    必需。 形式为数字、表达式、单元格引用或文本的条件，用来定义将计算平均值的单元格。 例如，条件可以表示为 32、"32"、">32"、"苹果" 或 B4。
Average_range    可选。 计算平均值的实际单元格组。 如果省略，则使用 range。
返回某个区域内满足给定条件的所有单元格的平均值（算术平均值）。
```



#### 10.8 RANK.EQ 函数

**返回一个数字在一组数字中的排位**

语法

```
RANK.EQ(number,ref,[order])
RANK.EQ 函数语法具有下列参数：
Number    必需。 要找到其排位的数字。
Ref    必需。 数字列表的数组，对数字列表的引用。 Ref 中的非数字值会被忽略。
Order    可选。 一个指定数字排位方式的数字。
返回一列数字的数字排位。 其大小与列表中其他值相关；如果多个值具有相同的排位，则返回该组值的最高排位。
如果要对列表进行排序，则数字排位可作为其位置。
```



#### 10.9 RANK.AVG 函数

**返回一个数字在一组数字中的排位**

语法

```
RANK.AVG(number,ref,[order])
RANK.AVG 函数语法具有下列参数：
Number    必需。 要找到其排位的数字。
Ref    必需。 数字列表的数组，对数字列表的引用。 Ref 中的非数字值会被忽略。
Order    可选。 一个指定数字排位方式的数字。
返回一列数字的数字排位：数字的排位是其大小与列表中其他值的比值；如果多个值具有相同的排位，则将返回平均排位。
```



#### 10.10 DELTA 函数

**测试两个值是否相等**

语法

```
DELTA(number1, [number2])
DELTA 函数语法具有下列参数：
Number1    必需。 第一个数字。
Number2    可选。 第二个数字。 如果省略，则假设 Number2 值为零。
检验两个值是否相等。 如果 number1=number2，则返回 1；否则返回 0。 可以使用此函数来筛选一组值。 例如，通过对几个 DELTA 函数进行求和，可计算相等对的数量。 此函数也称为 Kronecker Delta 函数。
```



#### 10.11 GESTEP 函数

**测试某值是否大于阈值**

语法

```
GESTEP(number, [step])
GESTEP 函数语法具有下列参数：
Number    必需。 要针对步骤进行测试的值。
Step    可选。 阈值。 如果省略 step 值，则 GESTEP 使用零。
如果 number ≥ step，则返回 1；否则返回 0（零）。 可以使用此函数来筛选一组值。 例如，通过对几个 GESTEP 函数进行求和，可计算超过阈值的值的计数。
```



#### 10.12 IS 类函数

**检验指定值**

语法

```
ISBLANK(value)
ISERR(value)
ISERROR(value)
ISLOGICAL(value)
ISNA(value)
ISNONTEXT(value)
ISNUMBER(value)
ISREF(value)
ISTEXT(value)
IS 函数语法具有下列参数：
value    必需。 指的是要测试的值。 参数 value 可以是空白（空单元格）、错误值、逻辑值、文本、数字、引用值，或者引用要测试的以上任意值的名称。
```

说明

```
这些函数统称为 IS 函数，此类函数可检验指定值并根据结果返回 TRUE 或 FALSE。 例如，如果参数 value 引用的是空单元格，则 ISBLANK 函数返回逻辑值 TRUE；否则，返回 FALSE。
在对某一值执行计算或执行其他操作之前，可以使用 IS 函数获取该值的相关信息。 例如，通过将 ISERROR 函数与 IF 函数结合使用，可以在出现错误时执行其他操作：
= IF ( ISERROR (A1), "出现错误。", A1 * 2)
此公式检验单元格 A1 中是否存在错误情形。 如果存在，则 IF 函数返回消息“出现错误”。 如果不存在，则 IF 函数执行计算 A1*2。
```

